{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///fxa-client.min.js","webpack:///webpack/bootstrap b56f7b7769039ed72f50","webpack:///./node_modules/sjcl/sjcl.js","webpack:///./client/lib/request.js","webpack:///./client/lib/errors.js","webpack:///./client/lib/hkdf.js","webpack:///./client/FxAccountClient.js","webpack:///./node_modules/es6-promise/dist/es6-promise.js","webpack:///(webpack)/buildin/global.js","webpack:///./client/lib/credentials.js","webpack:///./client/lib/hawk.js","webpack:///./client/lib/pbkdf2.js","webpack:///./client/lib/hawkCredentials.js","webpack:///./client/lib/metricsContext.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","v","a","b","length","sjcl","exception","invalid","e","g","f","h","k","q","r","t","u","w","slice","cipher","hash","keyexchange","mode","misc","codec","corrupt","toString","message","bug","notReady","aes","encrypt","decrypt","bitArray","bitSlice","clamp","extract","Math","floor","concat","getPartial","bitLength","ceil","partial","round","equal","push","pop","utf8String","fromBits","String","fromCharCode","decodeURIComponent","escape","toBits","unescape","encodeURIComponent","charCodeAt","hex","substr","replace","parseInt","base64","charAt","indexOf","base64url","sha256","reset","update","finalize","blockSize","splice","pow","hmac","j","mac","digest","pbkdf2","apply","hawk","ERRORS","Request","baseUri","xhr","options","_localtimeOffsetMsec","localtimeOffsetMsec","XMLHttpRequest","timeout","send","path","method","credentials","jsonPayload","uri","payload","JSON","stringify","open","Promise","reject","error","errno","resolve","onreadystatechange","readyState","result","responseText","parse","INVALID_TIMESTAMP","retrying","serverTime","Date","getTime","then","status","code","hawkHeader","client","header","contentType","setRequestHeader","field","headers","INCORRECT_EMAIL_CASE","hkdf","ikm","info","salt","prk","num_blocks","prev","output","truncated","ES6Promise","hawkCredentials","metricsContext","isUndefined","val","isNull","isEmptyObject","keys","isEmptyString","required","Error","FxAccountClient","config","uriVersionRegExp","test","VERSION","request","checkCreds","creds","oldUnwrapBKey","keyFetchToken","passwordChangeToken","polyfill","RegExp","signUp","email","password","setup","endpoint","data","emailUTF8","authPW","requestOpts","service","redirectTo","preVerified","resume","lang","Accept-Language","marshall","accountData","unwrapBKey","signIn","reason","unblockCode","originalLoginEmail","verificationMethod","skipCaseError","verifyCode","uid","reminder","type","marketingOptIn","verifyTokenCode","sessionToken","recoveryEmailStatus","recoveryEmailResendCode","passwordForgotSendCode","passwordForgotResendCode","passwordForgotToken","passwordForgotVerifyCode","passwordForgotStatus","accountReset","newPassword","accountResetToken","queryParams","accountKeys","bundleKey","unbundleKeyFetchResponse","bundle","kB","xor","wrapKB","kA","accountDestroy","response","accountStatus","accountStatusByEmail","sessionDestroy","customSessionToken","sessionStatus","sessionReauth","certificateSign","publicKey","duration","queryString","passwordChange","oldPassword","_passwordChangeStart","oldCreds","emailToHashWith","_passwordChangeKeys","_passwordChangeFinish","oldAuthPW","passwordData","defers","all","results","newCreds","hawkCreds","sessionData","newWrapKb","sessionTokenId","id","wrapKb","getRandomBytes","deviceRegister","deviceName","deviceType","deviceCallback","pushCallback","devicePublicKey","deviceAuthKey","pushPublicKey","pushAuthKey","deviceUpdate","deviceId","deviceDestroy","deviceList","sessions","sendUnblockCode","rejectUnblockCode","sendSms","phoneNumber","messageId","features","smsStatus","url","country","consumeSigninCode","flowId","flowBeginTime","recoveryEmails","recoveryEmailCreate","recoveryEmailDestroy","recoveryEmailSetPrimaryEmail","createTotpToken","deleteTotpToken","checkTotpTokenExists","verifyTotpCode","replaceRecoveryCodes","consumeRecoveryCode","_required","global","objectOrFunction","x","isFunction","setScheduler","scheduleFn","customSchedulerFn","setAsap","asapFn","asap","useVertxTimer","vertxNext","flush","useSetTimeout","globalSetTimeout","setTimeout","len","callback","queue","onFulfillment","onRejection","_arguments","arguments","parent","child","constructor","noop","PROMISE_ID","makePromise","_state","invokeCallback","_result","subscribe","resolve$1","Constructor","promise","selfFulfillment","TypeError","cannotReturnOwn","getThen","GET_THEN_ERROR","tryThen","then$$1","value","fulfillmentHandler","rejectionHandler","handleForeignThenable","thenable","sealed","fulfill","_label","handleOwnThenable","FULFILLED","REJECTED","handleMaybeThenable","maybeThenable","publishRejection","_onerror","publish","PENDING","_subscribers","subscribers","settled","detail","ErrorObject","tryCatch","TRY_CATCH_ERROR","hasCallback","succeeded","failed","initializePromise","resolver","nextId","Enumerator$1","input","_instanceConstructor","isArray","_remaining","Array","_enumerate","validationError","all$1","entries","race$1","_","reject$1","needsResolver","needsNew","Promise$2","polyfill$1","local","Function","P","promiseToString","cast","_isArray","arg","scheduleFlush","browserWindow","window","browserGlobal","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","isNode","process","isWorker","Uint8ClampedArray","importScripts","MessageChannel","nextTick","iterations","observer","node","document","createTextNode","observe","characterData","channel","port1","onmessage","port2","postMessage","vertx","runOnLoop","runOnContext","random","substring","_eachEntry","entry","resolve$$1","_then","_settledAt","_willSettleAt","state","enumerator","race","_setScheduler","_setAsap","_asap","catch","eval","kw","NAMESPACE","kwe","HKDF_SALT","emailInput","passwordInput","passwordUTF8","derive","quickStretchedPW","bitArray1","bitArray2","key","bitBundle","deriveBundleKeys","ciphertext","expectedHmac","hmacKey","keyAWrapB","xorKey","keyInfo","bitKeyInfo","keyMaterial","artifacts","err","timestamp","utils","now","algorithm","baseIndexOf","crypto","algorithms","parseUri","ts","nonce","randomString","resource","relative","host","hostname","port","ext","app","dlg","calculatePayloadHash","calculateMac","hasExt","escapeHeaderAttribute","authenticate","getResponseHeader","attrsAuth","parseAuthorizationHeader","calculateTsMac","tsm","setNtpOffset","attributes","authenticateTimestamp","updateClock","headerVersion","normalized","generateNormalizedString","toUpperCase","toLowerCase","parseContentType","storage","_cache","setItem","getItem","setStorage","ntpOffset","getNtpOffset","offset","attribute","split","headerParts","match","attributesString","$0","$1","$2","size","randomSource","join","array","fromIndex","index","uriRegex","uriByNumber","exec","protocol","deriveHawkCredentials","tokenHex","context","token","PREFIX_NAME","out","authKey","utmCampaign","utmContent","utmMedium","utmSource","utmTerm"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,gBAAAD,IAEAD,EAAA,gBAAAC,KACC,mBAAAK,WAAAC,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAR,OAGA,IAAAC,GAAAQ,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAX,WAUA,OANAM,GAAAE,GAAAI,KAAAX,EAAAD,QAAAC,IAAAD,QAAAO,GAGAN,EAAAU,GAAA,EAGAV,EAAAD,QAvBA,GAAAS,KA4DA,OAhCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAAAf,EAAAgB,EAAAC,GACAV,EAAAW,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAM,GAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDpB,EAAAuB,EAAA,IAGAvB,IAAAwB,EAAA,KDgBM,SAAU9B,EAAQD,GAExB,GAAIgC,GAA8BC,CE/ElCD,UAqBgBE,MArBhBD,EAAA,WAAwB,YAMxB,SAAAE,GAAAC,EAAAC,EAAAvB,GAAkB,OAAAuB,EAAAC,OAAA,SAAAC,GAAAC,UAAAC,QAAA,yBAA2E,IAAA1B,GAAAqB,EAAAM,EAAA5B,GAAA4B,EAAAL,EAAA,GAAAtB,EAAA,GAAA4B,EAAAN,EAAAvB,EAAA,KAAAC,EAAA,GAAA6B,EAAAP,EAAA,GAAAtB,EAAA,EAAqDsB,KAAAvB,EAAA,KAAAC,EAAA,EAAgB,IAAA8B,GAAAf,EAAAgB,EAAAnC,EAAAa,EAAAT,EAAAuB,OAAA,IAAAzB,EAAA,EAAAkB,GAAA,QAA2Cc,GAAAT,EAAAC,EAAAvB,GAASsB,EAAAS,EAAA,EAAO,IAAAE,GAAAF,EAAA,GAAAG,EAAAH,EAAA,GAAAI,EAAAJ,EAAA,GAAAK,EAAAL,EAAA,EAAgC,KAAAlC,EAAA,EAAQa,EAAAb,EAAIA,IAAAkC,EAAAT,EAAAM,IAAA,IAAAK,EAAAJ,GAAA,QAAAK,EAAAJ,GAAA,OAAAK,EAAA,IAAAZ,GAAAtB,EAAAF,GAAAiB,EAAAM,EAAAO,IAAA,IAAAI,EAAAH,GAAA,QAAAI,EAAAX,GAAA,OAAAY,EAAA,IAAAP,GAAA3B,EAAAF,EAAA,GAAAiC,EAAAV,EAAAQ,IAAA,IAAAG,EAAAV,GAAA,QAAAW,EAAAN,GAAA,OAAAO,EAAA,IAAAN,GAAA5B,EAAAF,EAAA,GAAAwB,EAAAD,EAAAC,IAAA,IAAAU,EAAAL,GAAA,QAAAM,EAAAL,GAAA,OAAAM,EAAA,IAAAL,GAAA7B,EAAAF,EAAA,GAAAA,GAAA,EAAA6B,EAAAG,EAAAF,EAAAb,EAAAc,EAAAE,CAAuO,KAAAnC,EAChf,EAAE,EAAAA,EAAIA,IAAAoB,EAAAjB,EAAA,GAAAH,KAAAuC,EAAAR,IAAA,QAAAQ,EAAAP,GAAA,YAAAO,EAAAN,GAAA,UAAAM,EAAA,IAAAb,GAAAtB,EAAAF,KAAAgC,EAAAH,IAAAC,IAAAC,IAAAP,IAAAQ,CAAkG,OAAAd,GAUxG,QAAAoB,GAAAf,EAAAC,GAAgB,GAAAvB,GAAAC,EAAA2B,EAAAC,EAAAN,EAAAe,MAAA,GAAAR,EAAAR,EAAAQ,EAAAC,EAAAT,EAAAM,EAAAZ,EAAAc,EAAA,GAAAE,EAAAF,EAAA,GAAApB,EAAAoB,EAAA,GAAAjC,EAAAiC,EAAA,GAAA/B,EAAA+B,EAAA,GAAAb,EAAAa,EAAA,GAAAG,EAAAH,EAAA,GAAAI,EAAAJ,EAAA,EAA2F,KAAA9B,EAAA,EAAQ,GAAAA,EAAKA,IAAA,GAAAA,EAAAC,EAAA4B,EAAA7B,IAAAC,EAAA4B,EAAA7B,EAAA,MAAA4B,EAAAC,EAAA7B,EAAA,OAAAC,EAAA4B,EAAA,GAAA7B,IAAAC,IAAA,EAAAA,IAAA,GAAAA,IAAA,EAAAA,GAAA,GAAAA,GAAA,KAAA2B,IAAA,GAAAA,IAAA,GAAAA,IAAA,GAAAA,GAAA,GAAAA,GAAA,IAAAC,EAAA,GAAA7B,GAAA6B,EAAA7B,EAAA,SAAAC,IAAAiC,GAAAnC,IAAA,EAAAA,IAAA,GAAAA,IAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,IAAAkC,EAAAlC,GAAAkB,EAAAgB,IAAAF,EAAA/B,GAAAkC,EAAAD,IAAAhB,IAAAlB,IAAAF,EAAAI,EAAA,EAAAJ,EAAAa,IAAAsB,IAAAhB,IAAAf,GAAA+B,EAAAtB,EAAAb,GAAAmC,EAAAtB,KAAAsB,IAAA,EAAAA,IAAA,GAAAA,IAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,KAAuSF,GAAA,GAAAA,EAAA,GAAAd,EAAA,EAAcc,EAAA,GAAAA,EAAA,GAAAE,EAAA,EAAcF,EAAA,GAAAA,EAAA,GAAApB,EAAA,EAAcoB,EAAA,GAAAA,EAAA,GAAAjC,EAAA,EAAciC,EAAA,GAAAA,EAAA,GAAA/B,EAAA,EAAc+B,EAAA,GAAAA,EAAA,GAAAb,EAAA,EAAca,EAAA,GACnfA,EAAA,GAAAG,EAAA,EAASH,EAAA,GAAAA,EAAA,GAAAI,EAAA,EAlB4B,GAAAT,IAAUc,UAASC,QAAQC,eAAeC,QAAQC,QAAQC,SAASlB,WAAYmB,QAAA,SAAAvB,GAAoB/B,KAAAuD,SAAA,WAAyB,kBAAAvD,KAAAwD,SAAgCxD,KAAAwD,QAAAzB,GAAeK,QAAA,SAAAL,GAAqB/B,KAAAuD,SAAA,WAAyB,kBAAAvD,KAAAwD,SAAgCxD,KAAAwD,QAAAzB,GAAe0B,IAAA,SAAA1B,GAAiB/B,KAAAuD,SAAA,WAAyB,cAAAvD,KAAAwD,SAA4BxD,KAAAwD,QAAAzB,GAAe2B,SAAA,SAAA3B,GAAsB/B,KAAAuD,SAAA,WAAyB,oBAAAvD,KAAAwD,SAAkCxD,KAAAwD,QAAAzB,IAqBnd,YApBA,KAAAnC,KAAAD,UAAAC,EAAAD,QAAAuC,GACAA,EAAAc,OAAAW,IAAA,SAAA5B,GAA4B/B,KAAAgC,EAAA,UAAAhC,KAAAsC,GAA0B,IAAAN,GAAAvB,EAAAC,EAAA2B,EAAAC,EAAAtC,KAAAgC,EAAA,MAAAO,EAAAvC,KAAAgC,EAAA,EAAuCA,GAAAD,EAAAE,MAAW,IAAAO,GAAA,CAAQ,QAAAR,GAAA,IAAAA,GAAA,IAAAA,EAAA,SAAAE,GAAAC,UAAAC,QAAA,uBAA2G,KAA3BpC,KAAAqC,GAAA3B,EAAAqB,EAAAgB,MAAA,GAAAV,MAA2BN,EAAAC,EAAQ,EAAAA,EAAA,GAAAD,EAASA,IAAKtB,EAAAC,EAAAqB,EAAA,IAAS,GAAAA,EAAAC,GAAA,IAAAA,GAAA,GAAAD,EAAAC,KAAAvB,EAAA6B,EAAA7B,IAAA,QAAA6B,EAAA7B,GAAA,YAAA6B,EAAA7B,GAAA,UAAA6B,EAAA,IAAA7B,GAAA,GAAAsB,EAAAC,IAAAvB,KAAA,EAAAA,IAAA,GAAA+B,GAAA,GAAAA,KAAA,OAAAA,GAAA,KAAqI9B,EAAAqB,GAAArB,EAAAqB,EAAAC,GAAAvB,CAAc,KAAAuB,EAAA,EAAQD,EAAEC,IAAAD,IAAAtB,EAAAC,EAAA,EAAAsB,EAAAD,IAAA,GAAAM,EAAAL,GAAA,GAAAD,GAAA,EAAAC,EAAAvB,EAAA8B,EAAA,GAAAD,EAAA7B,IAAA,KAAA8B,EAAA,GAAAD,EAAA7B,GAAA,SAAA8B,EAAA,GAAAD,EAAA7B,GAAA,QAAA8B,EAAA,GAAAD,EACvZ,IADuZ7B,KAEvZyB,EAAAc,OAAAW,IAAApC,WAA2BqC,QAAA,SAAA7B,GAAoB,MAAAD,GAAA9B,KAAA+B,EAAA,IAAmB8B,QAAA,SAAA9B,GAAqB,MAAAD,GAAA9B,KAAA+B,EAAA,IAAmBC,sCAAAM,EAAA,WAAoD,GAAAD,GAAAC,EAAAC,EAAAE,EAAAtB,EAAAb,EAAAE,EAAAuB,EAAA/B,KAAAgC,EAAA,GAAAA,EAAAhC,KAAAgC,EAAA,GAAAvB,EAAAsB,EAAA,GAAArB,EAAAsB,EAAA,GAAAQ,KAAAf,IAAkE,KAAAY,EAAA,EAAQ,IAAAA,EAAQA,IAAAZ,GAAAe,EAAAH,MAAA,OAAAA,GAAA,IAAAA,IAAkC,KAAAC,EAAAC,EAAA,GAAU9B,EAAA6B,GAAMA,GAAAG,GAAA,EAAAF,EAAAd,EAAAc,IAAA,EAA+J,IAA5IjC,EAAAiC,KAAA,EAAAA,GAAA,EAAAA,GAAA,EAAAA,GAAA,EAAwBjC,KAAA,MAAAA,EAAA,GAAgBG,EAAA6B,GAAAhC,EAAOI,EAAAJ,GAAAgC,EAAOnB,EAAAqB,EAAAH,EAAAG,EAAAC,EAAAD,EAAAF,KAAiB9B,EAAA,SAAAW,EAAA,MAAAkB,EAAA,IAAAI,EAAA,SAAAH,EAA4CnB,EAAA,IAAAqB,EAAAlC,GAAA,SAAAA,EAAyB+B,EAAA,EAAQ,EAAAA,EAAIA,IAAAN,EAAAM,GAAAC,GAAAnB,KAAA,GAAAA,IAAA,EAAAa,EAAAK,GAAA/B,GAAAE,KAAA,GAAAA,IAAA,CAAgD,KAAA6B,EAC7f,EAAE,EAAAA,EAAIA,IAAAN,EAAAM,GAAAN,EAAAM,GAAAU,MAAA,GAAAf,EAAAK,GAAAL,EAAAK,GAAAU,MAAA,KAGNb,EAAA4B,UAAeC,SAAA,SAAAhC,EAAAC,EAAAvB,GAA6E,MAApDsB,GAAAG,EAAA4B,SAAAxD,EAAAyB,EAAAgB,MAAAf,EAAA,WAAAA,IAAAe,MAAA,OAAoD,KAAAtC,EAAAsB,EAAAG,EAAA4B,SAAAE,MAAAjC,EAAAtB,EAAAuB,IAA+CiC,QAAA,SAAAlC,EAAAC,EAAAvB,GAAyB,GAAAC,GAAAwD,KAAAC,OAAAnC,EAAAvB,EAAA,GAA0B,aAAAuB,EAAAvB,EAAA,EAAAuB,GAAAD,EAAAC,EAAA,UAAAtB,EAAAqB,EAAAC,EAAA,UAAAtB,EAAAqB,EAAAC,EAAA,QAAAtB,IAAA,GAAAD,GAAA,GAA6E2D,OAAA,SAAArC,EAAAC,GAAsB,OAAAD,EAAAE,QAAA,IAAAD,EAAAC,OAAA,MAAAF,GAAAqC,OAAApC,EAAiD,IAAAvB,GAAAsB,IAAAE,OAAA,GAAAvB,EAAAwB,EAAA4B,SAAAO,WAAA5D,EAAkD,aAAAC,EAAAqB,EAAAqC,OAAApC,GAAAE,EAAA4B,SAAAxD,EAAA0B,EAAAtB,EAAA,EAAAD,EAAAsB,EAAAgB,MAAA,EAAAhB,EAAAE,OAAA,KAAyEqC,UAAA,SAAAvC,GAAuB,GAAAC,GAAAD,EAAAE,MAAe,YACnfD,EAAA,MAAAA,EAAA,GAAAE,EAAA4B,SAAAO,WAAAtC,EAAAC,EAAA,KAA8CgC,MAAA,SAAAjC,EAAAC,GAAqB,GAAAA,EAAA,GAAAD,EAAAE,OAAA,MAAAF,EAA0BA,KAAAgB,MAAA,EAAAmB,KAAAK,KAAAvC,EAAA,IAA6B,IAAAvB,GAAAsB,EAAAE,MAAwF,OAAzED,IAAA,GAAMvB,EAAA,GAAAuB,IAAAD,EAAAtB,EAAA,GAAAyB,EAAA4B,SAAAU,QAAAxC,EAAAD,EAAAtB,EAAA,eAAAuB,EAAA,MAAmED,GAASyC,QAAA,SAAAzC,EAAAC,EAAAvB,GAAyB,YAAAsB,EAAAC,GAAAvB,EAAA,EAAAuB,KAAA,GAAAD,GAAA,cAAAA,GAAgDsC,WAAA,SAAAtC,GAAwB,MAAAmC,MAAAO,MAAA1C,EAAA,oBAAuC2C,MAAA,SAAA3C,EAAAC,GAAqB,GAAAE,EAAA4B,SAAAQ,UAAAvC,KAAAG,EAAA4B,SAAAQ,UAAAtC,GAAA,QAAoE,IAAAtB,GAAAD,EAAA,CAAU,KAAAC,EAAA,EAAQqB,EAAAE,OAAAvB,EAAWA,IAAAD,GAAAsB,EAAArB,GAAAsB,EAAAtB,EAAiB,YAC1eD,GAAEH,EAAA,SAAAyB,EAAAC,EAAAvB,EAAAC,GAAqB,GAAA2B,EAAU,KAAJA,EAAA,MAAI,KAAA3B,UAAuBsB,GAAA,GAAMA,GAAA,GAAAtB,EAAAiE,KAAAlE,KAAA,CAAoB,QAAAuB,EAAA,MAAAtB,GAAA0D,OAAArC,EAA4B,KAAAM,EAAA,EAAQN,EAAAE,OAAAI,EAAWA,IAAA3B,EAAAiE,KAAAlE,EAAAsB,EAAAM,KAAAL,GAAAvB,EAAAsB,EAAAM,IAAA,GAAAL,CAAsJ,OAAlHK,GAAAN,EAAAE,OAAAF,IAAAE,OAAA,KAA2BF,EAAAG,EAAA4B,SAAAO,WAAAhC,GAA8B3B,EAAAiE,KAAAzC,EAAA4B,SAAAU,QAAAxC,EAAAD,EAAA,GAAAC,EAAAD,EAAA,GAAAtB,EAAAC,EAAAkE,MAAA,IAAyDlE,GAASS,EAAA,SAAAY,EAAAC,GAAiB,OAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,MACjTE,EAAAmB,MAAAwB,YAAuBC,SAAA,SAAA/C,GAAqB,GAAArB,GAAA2B,EAAAL,EAAA,GAAAvB,EAAAyB,EAAA4B,SAAAQ,UAAAvC,EAA0C,KAAArB,EAAA,EAAQD,EAAA,EAAAC,EAAMA,IAAA,MAAAA,KAAA2B,EAAAN,EAAArB,EAAA,IAAAsB,GAAA+C,OAAAC,aAAA3C,IAAA,IAAAA,IAAA,CAA+D,OAAA4C,oBAAAC,OAAAlD,KAAqCmD,OAAA,SAAApD,GAAoBA,EAAAqD,SAAAC,mBAAAtD,GAAkC,IAAAtB,GAAAuB,KAAAtB,EAAA,CAAe,KAAAD,EAAA,EAAQsB,EAAAE,OAAAxB,EAAWA,IAAAC,KAAA,EAAAqB,EAAAuD,WAAA7E,GAAA,MAAAA,KAAAuB,EAAA2C,KAAAjE,KAAA,EAAoG,OAA9C,GAAAD,GAAAuB,EAAA2C,KAAAzC,EAAA4B,SAAAU,QAAA,KAAA/D,GAAAC,IAA8CsB,IACpYE,EAAAmB,MAAAkC,KAAgBT,SAAA,SAAA/C,GAAqB,GAAAtB,GAAAuB,EAAA,EAAW,KAAAvB,EAAA,EAAQsB,EAAAE,OAAAxB,EAAWA,IAAAuB,IAAA,kBAAAD,EAAAtB,KAAA8C,SAAA,IAAAiC,OAAA,EAAwD,OAAAxD,GAAAwD,OAAA,EAAAtD,EAAA4B,SAAAQ,UAAAvC,GAAA,IAAgDoD,OAAA,SAAApD,GAAoB,GAAAC,GAAAtB,EAAAD,IAA+D,KAAlDsB,IAAA0D,QAAA,aAAyB/E,EAAAqB,EAAAE,OAAWF,GAAA,WAAcC,EAAA,EAAQD,EAAAE,OAAAD,EAAWA,GAAA,EAAAvB,EAAAkE,KAAA,EAAAe,SAAA3D,EAAAyD,OAAAxD,EAAA,OAA0C,OAAAE,GAAA4B,SAAAE,MAAAvD,EAAA,EAAAC,KAC3TwB,EAAAmB,MAAAsC,QAAmBtF,EAAA,mEAAAyE,SAAA,SAAA/C,EAAAC,EAAAvB,GAA8F,GAAAC,GAAA,GAAA2B,EAAA,EAAAC,EAAAJ,EAAAmB,MAAAsC,OAAAtF,EAAAkC,EAAA,EAAAC,EAAAN,EAAA4B,SAAAQ,UAAAvC,EAA+F,KAA3BtB,IAAA6B,IAAAkD,OAAA,YAA2B/E,EAAA,EAAQ+B,EAAA,EAAA9B,EAAAuB,QAAavB,GAAA4B,EAAAsD,QAAArD,EAAAR,EAAAtB,KAAA4B,KAAA,MAAAA,GAAAE,EAAAR,EAAAtB,IAAA,EAAA4B,KAAA,GAAA5B,MAAA8B,IAAA,EAAAF,GAAA,EAAyE,MAAK,EAAA3B,EAAAuB,SAAAD,GAAetB,GAAA,GAAQ,OAAAA,IAASyE,OAAA,SAAApD,EAAAC,GAAsBD,IAAA0D,QAAA,WAAwB,IAAA/E,GAAA8B,EAAA/B,KAAA4B,EAAA,EAAAC,EAAAJ,EAAAmB,MAAAsC,OAAAtF,EAAAkC,EAAA,CAAsE,KAA3BP,IAAAM,IAAAkD,OAAA,YAA2B9E,EAAA,EAAQqB,EAAAE,OAAAvB,EAAWA,IAAA,CAC1d,MAD+d8B,EAAAF,EAAAuD,QAAA9D,EAAA6D,OAAAlF,KAC/d,SAAAwB,GAAAC,UAAAC,QAAA,qBAA8DC,GAAA,IAAAA,GAAA,GAAA5B,EAAAkE,KAAApC,EAAAC,IAAAH,GAAAE,EAAAC,GAAA,GAAAH,OAAA,EAAAE,GAAAC,GAAA,GAAAH,GAAuG,MAA9C,IAAAA,GAAA5B,EAAAkE,KAAAzC,EAAA4B,SAAAU,QAAA,GAAAnC,EAAAE,EAAA,IAA8C9B,IAAWyB,EAAAmB,MAAAyC,WAAsBhB,SAAA,SAAA/C,GAAqB,MAAAG,GAAAmB,MAAAsC,OAAAb,SAAA/C,EAAA,MAAyCoD,OAAA,SAAApD,GAAoB,MAAAG,GAAAmB,MAAAsC,OAAAR,OAAApD,EAAA,KAAuCG,EAAAe,KAAA8C,OAAA,SAAAhE,GAA6B/B,KAAAqC,EAAA,IAAArC,KAAAsC,IAAoBP,GAAA/B,KAAAuC,EAAAR,EAAAQ,EAAAQ,MAAA,GAAA/C,KAAAU,EAAAqB,EAAArB,EAAAqC,MAAA,GAAA/C,KAAA+B,OAAA/B,KAAAgG,SAAqE9D,EAAAe,KAAA8C,OAAA9C,KAAA,SAAAlB,GAAkC,UAAAG,GAAAe,KAAA8C,QAAAE,OAAAlE,GAAAmE,YACvdhE,EAAAe,KAAA8C,OAAAxE,WAA4B4E,UAAA,IAAAH,MAAA,WAAyE,MAA1ChG,MAAAuC,EAAAvC,KAAAyC,EAAAM,MAAA,GAAuB/C,KAAAU,KAAUV,KAAA+B,EAAA,EAAS/B,MAAYiG,OAAA,SAAAlE,GAAoB,gBAAAA,OAAAG,EAAAmB,MAAAwB,WAAAM,OAAApD,GAAyD,IAAAC,GAAAvB,EAAAT,KAAAU,EAAAwB,EAAA4B,SAAAM,OAAApE,KAAAU,EAAAqB,EAA6F,KAA/CC,EAAAhC,KAAA+B,EAASA,EAAA/B,KAAA+B,EAAAC,EAAAE,EAAA4B,SAAAQ,UAAAvC,GAAsCC,EAAA,IAAAA,GAAA,IAAiBD,GAAAC,EAAKA,GAAA,IAAAc,EAAA9C,KAAAS,EAAA2F,OAAA,MAA8B,OAAApG,OAAYkG,SAAA,WAAqB,GAAAnE,GAAAC,EAAAhC,KAAAU,EAAAD,EAAAT,KAAAuC,EAAAP,EAAAE,EAAA4B,SAAAM,OAAApC,GAAAE,EAAA4B,SAAAU,QAAA,MAA+E,KAAAzC,EAAAC,EAAAC,OAAA,EAAiB,GAAAF,EAAKA,IAAAC,EAAA2C,KAAA,EACxc,KADsd3C,EAAA2C,KAAAT,KAAAC,MAAAnE,KAAA+B,EACne,aAAaC,EAAA2C,KAAA,EAAA3E,KAAA+B,GAAqBC,EAAAC,QAASa,EAAA9C,KAAAgC,EAAAoE,OAAA,MAAqC,OAAbpG,MAAAgG,QAAavF,GAASgC,KAAAJ,KAAAC,EAAA,WAAwB,QAAAP,MAAc,mBAAAA,EAAAmC,KAAAC,MAAApC,IAAA,EAAuC,GAAArB,GAAAsB,EAAA,EAAAvB,EAAA,CAAcsB,GAAA,KAAO,GAAAC,EAAKvB,IAAA,CAAK,IAAAC,EAAA,EAAQD,GAAAC,IAAOA,IAAA,MAAAD,EAAAC,EAAA,QAAAqB,EAA0B,GAAAC,IAAAhC,KAAAyC,EAAAT,GAAAD,EAAAmC,KAAAmC,IAAA5F,EAAA,MAAoCT,KAAAqC,EAAAL,GAAAD,EAAAmC,KAAAmC,IAAA5F,EAAA,MAA6BuB,OAExRE,EAAAkB,KAAAkD,KAAA,SAAAvE,EAAAC,GAA6BhC,KAAAuG,EAAAvE,KAAAE,EAAAe,KAAA8C,MAA6B,IAAArF,GAAAD,UAAA4B,EAAAL,EAAAT,UAAA4E,UAAA,EAA0F,KAA/CnG,KAAAS,GAAA,GAAAuB,GAAA,GAAAA,IAAqBD,EAAAE,OAAAI,IAAAN,EAAAC,EAAAiB,KAAAlB,IAA0BrB,EAAA,EAAQ2B,EAAA3B,EAAIA,IAAAD,EAAA,GAAAC,GAAA,UAAAqB,EAAArB,GAAAD,EAAA,GAAAC,GAAA,WAAAqB,EAAArB,EAAmDV,MAAAS,EAAA,GAAAwF,OAAAxF,EAAA,IAAuBT,KAAAS,EAAA,GAAAwF,OAAAxF,EAAA,IAAuBT,KAAAwC,EAAA,GAAAR,GAAAhC,KAAAS,EAAA,KAAyByB,EAAAkB,KAAAkD,KAAA/E,UAAAqC,QAAA1B,EAAAkB,KAAAkD,KAAA/E,UAAAiF,IAAA,SAAAzE,GAA0E,GAAA/B,KAAAQ,EAAA,SAAA0B,GAAAC,UAAAC,QAAA,0CAAqG,OAAfpC,MAAAiG,OAAAlE,GAAe/B,KAAAyG,OAAA1E,IACheG,EAAAkB,KAAAkD,KAAA/E,UAAAyE,MAAA,WAA0ChG,KAAAwC,EAAA,GAAAxC,MAAAuG,EAAAvG,KAAAS,EAAA,IAA6BT,KAAAQ,GAAA,GAAW0B,EAAAkB,KAAAkD,KAAA/E,UAAA0E,OAAA,SAAAlE,GAA4C/B,KAAAQ,GAAA,EAAUR,KAAAwC,EAAAyD,OAAAlE,IAAkBG,EAAAkB,KAAAkD,KAAA/E,UAAAkF,OAAA,WAA2C,GAAA1E,GAAA/B,KAAAwC,EAAA0D,WAAAnE,EAAA,GAAA/B,MAAAuG,EAAAvG,KAAAS,EAAA,IAAAwF,OAAAlE,GAAAmE,UAAoF,OAAblG,MAAAgG,QAAajE,GACzRG,EAAAkB,KAAAsD,OAAA,SAAA3E,EAAAC,EAAAvB,EAAAC,EAAA2B,GAA8C,GAAT5B,KAAA,IAAS,EAAAC,GAAA,EAAAD,EAAA,KAAAyB,GAAAC,UAAAC,QAAA,2BAAqE,iBAAAL,OAAAG,EAAAmB,MAAAwB,WAAAM,OAAApD,IAAyD,gBAAAC,OAAAE,EAAAmB,MAAAwB,WAAAM,OAAAnD,IAAyDK,KAAAH,EAAAkB,KAAAkD,KAAoBvE,EAAA,GAAAM,GAAAN,EAAW,IAAAO,GAAAC,EAAAC,EAAAf,EAAAgB,KAAAtB,EAAAe,EAAA4B,QAAiC,KAAArC,EAAA,GAAQf,GAAA,MAAA+B,EAAAR,OAAmBR,IAAA,CAAoC,IAA/BY,EAAAC,EAAAP,EAAA6B,QAAAzC,EAAAiD,OAAApC,GAAAP,KAA+Bc,EAAA,EAAQ9B,EAAA8B,EAAIA,IAAoB,IAAfD,EAAAP,EAAA6B,QAAAtB,GAAeE,EAAA,EAAQF,EAAAL,OAAAO,EAAWA,IAAAH,EAAAG,IAAAF,EAAAE,EAAeC,KAAA2B,OAAA/B,GAAkC,MAApB3B,KAAA+B,EAAAtB,EAAA6C,MAAAvB,EAAA/B,IAAoB+B,GACxcP,GAAgByE,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,IFoFV,SAAUhC,EAAQD,EAASO,GGzGjC,GAAAyB,GAAAC,CAGAD,IAAAzB,EAAA,GAAAA,EAAA,QAuHC2B,MAvHDD,EAAA,SAAAgF,EAAAC,GACA,YAYA,SAAAC,GAAAC,EAAAC,EAAAC,GACAA,IACAA,MAEAjH,KAAA+G,UACA/G,KAAAkH,qBAAAD,EAAAE,oBACAnH,KAAAgH,OAAAI,eACApH,KAAAqH,QAAAJ,EAAAI,SAAA,IAiGA,MAjFAP,GAAAvF,UAAA+F,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAT,GAEA,GAAAD,GAAA,GAAAhH,MAAAgH,IACAW,EAAA3H,KAAA+G,QAAAQ,EACAK,EAAA,KACA7H,EAAAC,IACAiH,SAEAS,IACAE,EAAAC,KAAAC,UAAAJ,GAGA,KACAV,EAAAe,KAAAP,EAAAG,GACK,MAAAtF,GACL,MAAA2F,SAAAC,QAA6BC,MAAA,gBAAA1E,QAAAnB,KAAA8F,MAAA,MAG7B,UAAAH,SAAA,SAAAI,EAAAH,GAwCA,GAvCAjB,EAAAK,QAAAtH,EAAAsH,QAEAL,EAAAqB,mBAAA,WACA,OAAArB,EAAAsB,WAAA,CACA,GAAAC,GAAAvB,EAAAwB,YACA,KACAD,EAAAV,KAAAY,MAAAzB,EAAAwB,cACW,MAAAnG,IAEX,GAAAkG,EAAAJ,MAAA,CAEA,GAAAI,EAAAJ,QAAAtB,EAAA6B,mBAAAzB,EAAA0B,SAWA,MAAAV,GAAAM,EAJA,OALAxI,GAAAmH,qBAAA,IADAqB,EAAAK,YACA,GAAAC,OAAAC,UAGA7B,EAAA0B,UAAA,EAEA5I,EAAAuH,KAAAC,EAAAC,EAAAC,EAAAC,EAAAT,GACA8B,KAAAX,EAAAH,GAOA,YAAAjB,EAAAgC,QAAA,MAAAhC,EAAAgC,OACA,MACAf,GADA,IAAAM,EAAAtG,QAC6BiG,MAAA,gBAAAC,MAAA,MAEAD,MAAA,gBAAA1E,QAAA+E,EAAAJ,MAAA,IAAAc,KAAAjC,EAAAgC,QAI7BZ,GAAAG,KAKAd,EAAA,CACA,GAAAyB,GAAAtC,EAAAuC,OAAAC,OAAAzB,EAAAH,GACAC,cACAG,UACAyB,YAAA,mBACAlC,oBAAApH,EAAAmH,sBAAA,GAEAF,GAAAsC,iBAAA,gBAAAJ,EAAAK,OAKA,GAFAvC,EAAAsC,iBAAA,mCAEArC,KAAAuC,QAEA,OAAAJ,KAAAnC,GAAAuC,QACAxC,EAAAsC,iBAAAF,EAAAnC,EAAAuC,QAAAJ,GAIApC,GAAAM,KAAAM,MAIAd,GAECH,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,IHiHK,SAAUhC,EAAQD,GI3OxB,GAAAgC,GAAAC,CAGAD,UAKCE,MALDD,EAAA,WACA,OACA8G,kBAAA,IACAe,qBAAA,MAEC9C,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,IJmPK,SAAUhC,EAAQD,EAASO,GK3PjC,GAAAyB,GAAAC,CAGAD,IAAAzB,EAAA,QAiDC2B,MAjDDD,EAAA,SAAAM,GACA,YAaA,SAAAwH,GAAAC,EAAAC,EAAAC,EAAA5H,GAEA,GAAAuE,GAAA,GAAAtE,GAAAkB,KAAAkD,KAAAuD,EAAA3H,EAAAe,KAAA8C,OACAS,GAAAP,OAAA0D,EAWA,QARAG,GAAAtD,EAAAC,SAIAsD,EAAA7F,KAAAK,KAAAtC,EADA,IAEA+H,EAAA9H,EAAAmB,MAAAkC,IAAAJ,OAAA,IACA8E,EAAA,GAEA5J,EAAA,EAAmB0J,EAAA1J,EAAgBA,IAAA,CACnC,GAAAiG,GAAA,GAAApE,GAAAkB,KAAAkD,KAAAwD,EAAA5H,EAAAe,KAAA8C,OAOAO,GAAAL,OALA/D,EAAA4B,SAAAM,OACAlC,EAAA4B,SAAAM,OAAA4F,EAAAJ,GACA1H,EAAAmB,MAAAwB,WAAAM,OAAAJ,OAAAC,aAAA3E,EAAA,MAKA2J,EAAA1D,EAAAG,SACAwD,GAAA/H,EAAAmB,MAAAkC,IAAAT,SAAAkF,GAGA,GAAAE,GAAAhI,EAAA4B,SAAAE,MAAA9B,EAAAmB,MAAAkC,IAAAJ,OAAA8E,GAAA,EAAAhI,EAEA,OAAA+F,SAAAI,QAAA8B,GAGA,MAAAR,IAEC/C,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,ILmQK,SAAUhC,EAAQD,EAASO,GMvTjC,GAAAyB,GAAAC,CAGAD,IACAzB,EAAA,GACAA,EAAA,GACAA,EAAA,GACAA,EAAA,GACAA,EAAA,IACAA,EAAA,IACAA,EAAA,QAs1DC2B,MAr1DDD,EAAA,SAAAuI,EAAAjI,EAAAuF,EAAAZ,EAAAuD,EAAAC,EAAAvD,GACA,YASA,SAAAwD,GAAAC,GACA,gBAAAA,EAGA,QAAAC,GAAAD,GACA,cAAAA,EAGA,QAAAE,GAAAF,GACA,0BAAAzJ,OAAAS,UAAAgC,SAAAhD,KAAAgK,KAAAzJ,OAAA4J,KAAAH,GAAAtI,OAGA,QAAA0I,GAAAJ,GACA,WAAAA,EAGA,QAAAK,GAAAL,EAAA5J,GACA,GAAA2J,EAAAC,IACAC,EAAAD,IACAE,EAAAF,IACAI,EAAAJ,GACA,KAAAM,OAAA,WAAAlK,GAUA,QAAAmK,GAAAnD,EAAAoD,GACA,IAAApD,IAAAoD,EACA,KAAAF,OAAA,0EAYA,IATA,gBAAAlD,KACAoD,EAAApD,MACAA,EAAAoD,EAAApD,SAGA,KAAAoD,IACAA,OAGApD,EACA,KAAAkD,OAAA,+BAGAG,GAAAC,KAAAtD,KACAA,IAAA,IAAAuD,GAGAlL,KAAAmL,QAAA,GAAArE,GAAAa,EAAAoD,EAAA/D,KAAiDG,oBAAA4D,EAAA5D,sBAskCjD,QAAAiE,GAAAC,GACAT,EAAAS,EAAA,eACAT,EAAAS,EAAAC,cAAA,6BACAV,EAAAS,EAAAE,cAAA,6BACAX,EAAAS,EAAAG,oBAAA,mCAroCArB,EAAAsB,UAEA,IAAAP,GAAA,KACAF,EAAAU,OAAA,IAAAR,EAAA,IA60DA,OAlxDAJ,GAAAI,UAgCAJ,EAAAvJ,UAAAoK,OAAA,SAAAC,EAAAC,EAAA5E,GACA,GAAAlH,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAAgB,EAAA,SACAhB,EAAAiB,EAAA,YAEApE,EAAAqE,MAAAF,EAAAC,KAEA9C,KACA,SAAAR,GAEA,GAAAwD,GAAA,kBACAC,GACAJ,MAAArD,EAAA0D,UACAC,OAAAhK,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAA2D,SAEAC,IAmCA,OAjCAlF,KACAA,EAAAmF,UACAJ,EAAAI,QAAAnF,EAAAmF,SAGAnF,EAAAoF,aACAL,EAAAK,WAAApF,EAAAoF,YAIApF,EAAAqF,cACAN,EAAAM,YAAArF,EAAAqF,aAGArF,EAAAsF,SACAP,EAAAO,OAAAtF,EAAAsF,QAGAtF,EAAAyD,OACAqB,GAAA,cAGA9E,EAAAuF,OACAL,EAAA3C,SACAiD,kBAAAxF,EAAAuF,OAIAvF,EAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,kBAIAtK,EAAAoL,QAAA7D,KAAAyE,EAAA,YAAAC,EAAAG,GACApD,KACA,SAAA4D,GAIA,MAHA1F,MAAAyD,OACAiC,EAAAC,WAAA1K,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAAqE,aAEAD,OA8CA7B,EAAAvJ,UAAAsL,OAAA,SAAAjB,EAAAC,EAAA5E,GACA,GAAAlH,GAAAC,IAGA,OAFAiH,SAEAe,QAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAAgB,EAAA,SACAhB,EAAAiB,EAAA,YAEApE,EAAAqE,MAAAF,EAAAC,KAEA9C,KACA,SAAAR,GACA,GAAAwD,GAAA,gBAEA9E,GAAAyD,OACAqB,GAAA,aAGA,IAAAC,IACAJ,MAAArD,EAAA0D,UACAC,OAAAhK,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAA2D,QAmCA,OAhCAjF,GAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,iBAGApD,EAAA6F,SACAd,EAAAc,OAAA7F,EAAA6F,QAGA7F,EAAAoF,aACAL,EAAAK,WAAApF,EAAAoF,YAGApF,EAAAsF,SACAP,EAAAO,OAAAtF,EAAAsF,QAGAtF,EAAAmF,UACAJ,EAAAI,QAAAnF,EAAAmF,SAGAnF,EAAA8F,cACAf,EAAAe,YAAA9F,EAAA8F,aAGA9F,EAAA+F,qBACAhB,EAAAgB,mBAAA/F,EAAA+F,oBAGA/F,EAAAgG,qBACAjB,EAAAiB,mBAAAhG,EAAAgG,oBAGAlN,EAAAoL,QAAA7D,KAAAyE,EAAA,YAAAC,GACAjD,KACA,SAAA4D,GAIA,MAHA1F,GAAAyD,OACAiC,EAAAC,WAAA1K,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAAqE,aAEAD,GAEA,SAAAzE,GACA,GAAAA,KAAA0D,OAAA1D,EAAAC,QAAAtB,EAAA4C,uBAAAxC,EAAAiG,cAIA,MAHAjG,GAAAiG,eAAA,EACAjG,EAAA+F,mBAAApB,EAEA7L,EAAA8M,OAAA3E,EAAA0D,MAAAC,EAAA5E,EAEA,MAAAiB,QAuBA4C,EAAAvJ,UAAA4L,WAAA,SAAAC,EAAAnE,EAAAhC,GACA,GAAAlH,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WACA6B,EAAAwC,EAAA,OACAxC,EAAA3B,EAAA,cAEA,IAAA+C,IACAoB,MACAnE,OAqBA,OAlBAhC,KACAA,EAAAmF,UACAJ,EAAAI,QAAAnF,EAAAmF,SAGAnF,EAAAoG,WACArB,EAAAqB,SAAApG,EAAAoG,UAGApG,EAAAqG,OACAtB,EAAAsB,KAAArG,EAAAqG,MAGArG,EAAAsG,iBACAvB,EAAAuB,gBAAA,IAIAxN,EAAAoL,QAAA7D,KAAA,0CAAA0E,MAIAlB,EAAAvJ,UAAAiM,gBAAA,SAAAC,EAAAL,EAAAnE,GACA,GAAAlJ,GAAAC,IAMA,OAJA4K,GAAAwC,EAAA,OACAxC,EAAA3B,EAAA,qBACA2B,EAAA6C,EAAA,gBAEAzF,QAAAI,UACAW,KAAA,WACA,MAAAqB,GAAAqD,EAAA,eA7UA,MA+UA1E,KAAA,SAAAsC,GAMA,MAAAtL,GAAAoL,QAAA7D,KAAA,+BAAA+D,GAJA+B,MACAnE,YAYA6B,EAAAvJ,UAAAmM,oBAAA,SAAAD,GACA,GAAA1N,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eArWA,MAuWA1E,KAAA,SAAAsC,GACA,MAAAtL,GAAAoL,QAAA7D,KAAA,+BAAA+D,MA2BAP,EAAAvJ,UAAAoM,wBAAA,SAAAF,EAAAxG,GACA,GAAAlH,GAAAC,KACAgM,KACAG,IAEA,OAAAnE,SAAAI,UACAW,KAAA,WA+BA,MA9BA6B,GAAA6C,EAAA,gBAEAxG,IACAA,EAAA2E,QACAI,EAAAJ,MAAA3E,EAAA2E,OAGA3E,EAAAmF,UACAJ,EAAAI,QAAAnF,EAAAmF,SAGAnF,EAAAoF,aACAL,EAAAK,WAAApF,EAAAoF,YAGApF,EAAAsF,SACAP,EAAAO,OAAAtF,EAAAsF,QAGAtF,EAAAqG,OACAtB,EAAAsB,KAAArG,EAAAqG,MAGArG,EAAAuF,OACAL,EAAA3C,SACAiD,kBAAAxF,EAAAuF,QAKApC,EAAAqD,EAAA,eAxaA,MA0aA1E,KAAA,SAAAsC,GACA,MAAAtL,GAAAoL,QAAA7D,KAAA,qCAAA+D,EAAAW,EAAAG,MAgCArB,EAAAvJ,UAAAqM,uBAAA,SAAAhC,EAAA3E,GACA,GAAAlH,GAAAC,KACAgM,GACAJ,SAEAO,IAEA,OAAAnE,SAAAI,UACAW,KAAA,WA2BA,MA1BA6B,GAAAgB,EAAA,SAEA3E,IACAA,EAAAmF,UACAJ,EAAAI,QAAAnF,EAAAmF,SAGAnF,EAAAoF,aACAL,EAAAK,WAAApF,EAAAoF,YAGApF,EAAAsF,SACAP,EAAAO,OAAAtF,EAAAsF,QAGAtF,EAAAuF,OACAL,EAAA3C,SACAiD,kBAAAxF,EAAAuF,OAIAvF,EAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,kBAIAtK,EAAAoL,QAAA7D,KAAA,yCAAA0E,EAAAG,MAiCArB,EAAAvJ,UAAAsM,yBAAA,SAAAjC,EAAAkC,EAAA7G,GACA,GAAAlH,GAAAC,KACAgM,GACAJ,SAEAO,IAEA,OAAAnE,SAAAI,UACAW,KAAA,WA4BA,MA3BA6B,GAAAgB,EAAA,SACAhB,EAAAkD,EAAA,uBAEA7G,IACAA,EAAAmF,UACAJ,EAAAI,QAAAnF,EAAAmF,SAGAnF,EAAAoF,aACAL,EAAAK,WAAApF,EAAAoF,YAGApF,EAAAsF,SACAP,EAAAO,OAAAtF,EAAAsF,QAGAtF,EAAAuF,OACAL,EAAA3C,SACAiD,kBAAAxF,EAAAuF,OAIAvF,EAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,kBAIAD,EAAA0D,EAAA,sBAnjBA,MAqjBA/E,KAAA,SAAAsC,GACA,MAAAtL,GAAAoL,QAAA7D,KAAA,sCAAA+D,EAAAW,EAAAG,MAuBArB,EAAAvJ,UAAAwM,yBAAA,SAAA9E,EAAA6E,EAAA7G,GACA,GAAAlH,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAA3B,EAAA,cACA2B,EAAAkD,EAAA,uBAEA1D,EAAA0D,EAAA,sBArlBA,MAulBA/E,KAAA,SAAAsC,GACA,GAAAW,IACA/C,OAOA,OAJAhC,MAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,iBAGAtK,EAAAoL,QAAA7D,KAAA,sCAAA+D,EAAAW,MAYAlB,EAAAvJ,UAAAyM,qBAAA,SAAAF,GACA,GAAA/N,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAAkD,EAAA,uBAEA1D,EAAA0D,EAAA,sBAnnBA,MAqnBA/E,KAAA,SAAAsC,GACA,MAAAtL,GAAAoL,QAAA7D,KAAA,gCAAA+D,MA6BAP,EAAAvJ,UAAA0M,aAAA,SAAArC,EAAAsC,EAAAC,EAAAlH,GACA,GAEA2F,GAFA7M,EAAAC,KACAgM,IAaA,OAVA/E,SAEAA,EAAAwG,eACAzB,EAAAyB,aAAAxG,EAAAwG,cAGAxG,EAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,iBAGArC,QAAAI,UACAW,KAAA,WASA,MARA6B,GAAAgB,EAAA,SACAhB,EAAAsD,EAAA,gBACAtD,EAAAuD,EAAA,qBAEAlH,EAAAyD,MACAE,EAAA3D,EAAAwG,aAAA,gBAGAhG,EAAAqE,MAAAF,EAAAsC,KAEAnF,KACA,SAAAR,GAOA,MANAtB,GAAAyD,OACAkC,EAAA1K,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAAqE,aAGAZ,EAAAE,OAAAhK,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAA2D,QAEA9B,EAAA+D,EAAA,oBAtrBA,MAwrBApF,KACA,SAAAsC,GACA,GAAA+C,GAAA,EAMA,OALAnH,GAAAyD,OACA0D,EAAA,cAIArO,EAAAoL,QAAA7D,KADA,iBAAA8G,EACA,OAAA/C,EAAAW,GACAjD,KACA,SAAA4D,GAKA,MAJA1F,GAAAyD,MAAAiC,EAAApB,gBACAoB,EAAAC,cAGAD,OAeA7B,EAAAvJ,UAAA8M,YAAA,SAAA9C,EAAAD,GACA,GAAAvL,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAAW,EAAA,iBACAX,EAAAU,EAAA,iBAEAlB,EAAAmB,EAAA,sBAEAxC,KAAA,SAAAsC,GACA,GAAAiD,GAAApM,EAAAmB,MAAAkC,IAAAT,SAAAuG,EAAAiD,UAEA,OAAAvO,GAAAoL,QAAA7D,KAAA,sBAAA+D,GACAtC,KACA,SAAAnB,GAEA,MAAAH,GAAA8G,yBAAAD,EAAA1G,EAAA4G,YAGAzF,KAAA,SAAA2B,GACA,OACA+D,GAAAvM,EAAAmB,MAAAkC,IAAAT,SACA2C,EAAAiH,IACAxM,EAAAmB,MAAAkC,IAAAJ,OAAAuF,EAAAiE,QACAzM,EAAAmB,MAAAkC,IAAAJ,OAAAmG,KAGAsD,GAAAlE,EAAAkE,OAgBA9D,EAAAvJ,UAAAsN,eAAA,SAAAjD,EAAAC,EAAA5E,GACA,GAAAlH,GAAAC,IAGA,OAFAiH,SAEAe,QAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAAgB,EAAA,SACAhB,EAAAiB,EAAA,YAEApE,EAAAqE,MAAAF,EAAAC,KAEA9C,KACA,SAAAR,GACA,GAAAyD,IACAJ,MAAArD,EAAA0D,UACAC,OAAAhK,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAA2D,QAGA,OAAAnM,GAAAoL,QAAA7D,KAAA,+BAAA0E,GACAjD,KACA,SAAA+F,GACA,MAAAA,IAEA,SAAA5G,GAEA,GAAAA,KAAA0D,OAAA1D,EAAAC,QAAAtB,EAAA4C,uBAAAxC,EAAAiG,cAGA,MAFAjG,GAAAiG,eAAA,EAEAnN,EAAA8O,eAAA3G,EAAA0D,MAAAC,EAAA5E,EAEA,MAAAiB,QAeA4C,EAAAvJ,UAAAwN,cAAA,SAAA3B,GACA,GAAArN,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAAwC,EAAA,OAEArN,EAAAoL,QAAA7D,KAAA,uBAAA8F,EAAA,UAWAtC,EAAAvJ,UAAAyN,qBAAA,SAAApD,GACA,GAAA7L,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAAgB,EAAA,SAEA7L,EAAAoL,QAAA7D,KAAA,+BAAmEsE,aAanEd,EAAAvJ,UAAA0N,eAAA,SAAAxB,EAAAxG,GACA,GAAAlH,GAAAC,KACAgM,IAOA,OANA/E,SAEAA,EAAAiI,qBACAlD,EAAAkD,mBAAAjI,EAAAiI,oBAGAlH,QAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eAl2BA,MAo2BA1E,KAAA,SAAAsC,GACA,MAAAtL,GAAAoL,QAAA7D,KAAA,0BAAA+D,EAAAW,MAWAlB,EAAAvJ,UAAA4N,cAAA,SAAA1B,GACA,GAAA1N,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eAv3BA,MAy3BA1E,KAAA,SAAAsC,GACA,MAAAtL,GAAAoL,QAAA7D,KAAA,wBAAA+D,MA4CAP,EAAAvJ,UAAA6N,cAAA,SAAA3B,EAAA7B,EAAAC,EAAA5E,GACA,GAAAlH,GAAAC,IAGA,OAFAiH,SAEAe,QAAAI,UACAW,KAAA,WAKA,MAJA6B,GAAA6C,EAAA,gBACA7C,EAAAgB,EAAA,SACAhB,EAAAiB,EAAA,YAEApE,EAAAqE,MAAAF,EAAAC,KAEA9C,KACA,SAAAR,GACA,GAAAwD,GAAA,iBAEA9E,GAAAyD,OACAqB,GAAA,aAGA,IAAAC,IACAJ,MAAArD,EAAA0D,UACAC,OAAAhK,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAA2D,QAmCA,OAhCAjF,GAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,iBAGApD,EAAA6F,SACAd,EAAAc,OAAA7F,EAAA6F,QAGA7F,EAAAoF,aACAL,EAAAK,WAAApF,EAAAoF,YAGApF,EAAAsF,SACAP,EAAAO,OAAAtF,EAAAsF,QAGAtF,EAAAmF,UACAJ,EAAAI,QAAAnF,EAAAmF,SAGAnF,EAAA8F,cACAf,EAAAe,YAAA9F,EAAA8F,aAGA9F,EAAA+F,qBACAhB,EAAAgB,mBAAA/F,EAAA+F,oBAGA/F,EAAAgG,qBACAjB,EAAAiB,mBAAAhG,EAAAgG,oBAGA7C,EAAAqD,EAAA,eA/9BA,IAg+BA1E,KAAA,SAAAsC,GACA,MAAAtL,GAAAoL,QAAA7D,KAAAyE,EAAA,OAAAV,EAAAW,KAEAjD,KACA,SAAA4D,GAIA,MAHA1F,GAAAyD,OACAiC,EAAAC,WAAA1K,EAAAmB,MAAAkC,IAAAT,SAAAyD,EAAAqE,aAEAD,GAEA,SAAAzE,GACA,GAAAA,KAAA0D,OAAA1D,EAAAC,QAAAtB,EAAA4C,uBAAAxC,EAAAiG,cAIA,MAHAjG,GAAAiG,eAAA,EACAjG,EAAA+F,mBAAApB,EAEA7L,EAAAqP,cAAA3B,EAAAvF,EAAA0D,MAAAC,EAAA5E,EAEA,MAAAiB,QAmBA4C,EAAAvJ,UAAA8N,gBAAA,SAAA5B,EAAA6B,EAAAC,EAAAtI,GACA,GAAAlH,GAAAC,KACAgM,GACAsD,YACAC,WAGA,OAAAvH,SAAAI,UACAW,KAAA,WAKA,MAJA6B,GAAA6C,EAAA,gBACA7C,EAAA0E,EAAA,aACA1E,EAAA2E,EAAA,YAEAnF,EAAAqD,EAAA,eAjhCA,MAmhCA1E,KAAA,SAAAsC,GACApE,OAEA,IAAAuI,GAAA,EAKA,OAJAvI,GAAAmF,UACAoD,EAAA,YAAAnK,mBAAA4B,EAAAmF,UAGArM,EAAAoL,QAAA7D,KAAA,oBAAAkI,EAAA,OAAAnE,EAAAW,MAmBAlB,EAAAvJ,UAAAkO,eAAA,SAAA7D,EAAA8D,EAAAxB,EAAAjH,GACA,GAAAlH,GAAAC,IAGA,OAFAiH,SAEAe,QAAAI,UACAW,KAAA,WAKA,MAJA6B,GAAAgB,EAAA,SACAhB,EAAA8E,EAAA,gBACA9E,EAAAsD,EAAA,gBAEAnO,EAAA4P,qBAAA/D,EAAA8D,KAEA3G,KAAA,SAAAtB,GAEA,GAAAmI,GAAAnI,EACAoI,EAAApI,EAAAoI,iBAAAjE,CAEA,OAAA7L,GAAA+P,oBAAAF,GACA7G,KAAA,SAAA2B,GAEA,MAAA3K,GAAAgQ,sBAAAF,EAAA3B,EAAA0B,EAAAlF,EAAAzD,QAkBA6D,EAAAvJ,UAAAoO,qBAAA,SAAA/D,EAAA8D,EAAAzI,GACA,GAAAlH,GAAAC,IAGA,OAFAiH,SAEAe,QAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAAgB,EAAA,SACAhB,EAAA8E,EAAA,gBAEAjI,EAAAqE,MAAAF,EAAA8D,KAEA3G,KAAA,SAAA6G,GACA,GAAA5D,IACAJ,MAAAgE,EAAA3D,UACA+D,UAAA9N,EAAAmB,MAAAkC,IAAAT,SAAA8K,EAAA1D,QAGA,OAAAnM,GAAAoL,QAAA7D,KAAA,qCAAA0E,GACAjD,KACA,SAAAkH,GAMA,MALAA,GAAA3E,cAAApJ,EAAAmB,MAAAkC,IAAAT,SAAA8K,EAAAhD,YAIAqD,EAAAJ,gBAAAjE,EACAqE,GAEA,SAAA/H,GAEA,GAAAA,KAAA0D,OAAA1D,EAAAC,QAAAtB,EAAA4C,uBAAAxC,EAAAiG,cAGA,MAFAjG,GAAAiG,eAAA,EAEAnN,EAAA4P,qBAAAzH,EAAA0D,MAAA8D,EAAAzI,EAEA,MAAAiB,QAsBA4C,EAAAvJ,UAAAuO,oBAAA,SAAAF,GACA,GAAA7P,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WACAqC,EAAAwE,KAEA7G,KAAA,WACA,MAAAhJ,GAAAsO,YAAAuB,EAAArE,cAAAqE,EAAAtE,kBAqBAR,EAAAvJ,UAAAwO,sBAAA,SAAAnE,EAAAsC,EAAA0B,EAAAlF,EAAAzD,GACAA,OACA,IAAAlH,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WACA6B,EAAAgB,EAAA,SACAhB,EAAAsD,EAAA,gBACA9C,EAAAwE,GACAhF,EAAAF,EAAA,QACAE,EAAAF,EAAA+D,GAAA,UAEA,IAAAyB,KASA,OARAA,GAAAvL,KAAA8C,EAAAqE,MAAAF,EAAAsC,IACAgC,EAAAvL,KAAAyF,EAAAwF,EAAApE,oBAAA,sBAvrCA,KAyrCAvE,EAAAwG,cAEAyC,EAAAvL,KAAAyF,EAAAnD,EAAAwG,aAAA,eA3rCA,KA8rCAzF,QAAAmI,IAAAD,KAEAnH,KAAA,SAAAqH,GACA,GAAAC,GAAAD,EAAA,GACAE,EAAAF,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAtO,EAAAmB,MAAAkC,IAAAT,SACA2C,EAAAiH,IACAxM,EAAAmB,MAAAkC,IAAAJ,OAAAuF,EAAA+D,IACA4B,EAAAzD,aAIAwB,EAAA,EACAnH,GAAAyD,OACA0D,EAAA,aAGA,IAAAqC,EAKA,OAJAF,MAAAG,KACAD,EAAAF,EAAAG,IAGA3Q,EAAAoL,QAAA7D,KAAA,0BAAA8G,EAAA,OAAAkC,GACAK,OAAAH,EACAtE,OAAAhK,EAAAmB,MAAAkC,IAAAT,SAAAuL,EAAAnE,QACAuB,aAAAgD,IAEA1H,KAAA,SAAA4D,GAIA,MAHA1F,GAAAyD,MAAAiC,EAAApB,gBACAoB,EAAAC,WAAA1K,EAAAmB,MAAAkC,IAAAT,SAAAuL,EAAAzD,aAEAD,OAWA7B,EAAAvJ,UAAAqP,eAAA,WAEA,MAAA5Q,MAAAmL,QAAA7D,KAAA,6BAgBAwD,EAAAvJ,UAAAsP,eAAA,SAAApD,EAAAqD,EAAAC,EAAA9J,GACA,GAAAkE,GAAAnL,KAAAmL,OAGA,OAFAlE,SAEAe,QAAAI,UACAW,KAAA,WAKA,MAJA6B,GAAA6C,EAAA,gBACA7C,EAAAkG,EAAA,cACAlG,EAAAmG,EAAA,cAEA3G,EAAAqD,EAAA,eArwCA,MAuwCA1E,KAAA,SAAAsC,GACA,GAAAW,IACArL,KAAAmQ,EACAxD,KAAAyD,EAYA,OATA9J,GAAA+J,iBACAhF,EAAAiF,aAAAhK,EAAA+J,gBAGA/J,EAAAiK,iBAAAjK,EAAAkK,gBACAnF,EAAAoF,cAAAnK,EAAAiK,gBACAlF,EAAAqF,YAAApK,EAAAkK,eAGAhG,EAAA7D,KAAA,yBAAA+D,EAAAW,MAiBAlB,EAAAvJ,UAAA+P,aAAA,SAAA7D,EAAA8D,EAAAT,EAAA7J,GACA,GAAAkE,GAAAnL,KAAAmL,OAGA,OAFAlE,SAEAe,QAAAI,UACAW,KAAA,WAKA,MAJA6B,GAAA6C,EAAA,gBACA7C,EAAA2G,EAAA,YACA3G,EAAAkG,EAAA,cAEA1G,EAAAqD,EAAA,eAjzCA,MAmzCA1E,KAAA,SAAAsC,GACA,GAAAW,IACA0E,GAAAa,EACA5Q,KAAAmQ,EAYA,OATA7J,GAAA+J,iBACAhF,EAAAiF,aAAAhK,EAAA+J,gBAGA/J,EAAAiK,iBAAAjK,EAAAkK,gBACAnF,EAAAoF,cAAAnK,EAAAiK,gBACAlF,EAAAqF,YAAApK,EAAAkK,eAGAhG,EAAA7D,KAAA,yBAAA+D,EAAAW,MAYAlB,EAAAvJ,UAAAiQ,cAAA,SAAA/D,EAAA8D,GACA,GAAApG,GAAAnL,KAAAmL,OAEA,OAAAnD,SAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAA6C,EAAA,gBACA7C,EAAA2G,EAAA,YAEAnH,EAAAqD,EAAA,eAt1CA,MAw1CA1E,KAAA,SAAAsC,GAKA,MAAAF,GAAA7D,KAAA,iCAAA+D,GAHAqF,GAAAa,OAcAzG,EAAAvJ,UAAAkQ,WAAA,SAAAhE,GACA,GAAAtC,GAAAnL,KAAAmL,OAEA,OAAAnD,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eA/2CA,MAi3CA1E,KAAA,SAAAsC,GACA,MAAAF,GAAA7D,KAAA,yBAAA+D,MAWAP,EAAAvJ,UAAAmQ,SAAA,SAAAjE,GACA,GAAAtC,GAAAnL,KAAAmL,OAEA,OAAAnD,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eAp4CA,MAs4CA1E,KAAA,SAAAsC,GACA,MAAAF,GAAA7D,KAAA,0BAAA+D,MAqBAP,EAAAvJ,UAAAoQ,gBAAA,SAAA/F,EAAA3E,GACA,GAAAlH,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WACA6B,EAAAgB,EAAA,QAEA,IAAAI,IACAJ,QAOA,OAJA3E,MAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,iBAGAtK,EAAAoL,QAAA7D,KAAA,+CAAA0E,MAaAlB,EAAAvJ,UAAAqQ,kBAAA,SAAAxE,EAAAL,GACA,GAAAhN,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WASA,MARA6B,GAAAwC,EAAA,OACAxC,EAAAmC,EAAA,eAOAhN,EAAAoL,QAAA7D,KAAA,kDAJA8F,MACAL,mBA2BAjC,EAAAvJ,UAAAsQ,QAAA,SAAApE,EAAAqE,EAAAC,EAAA9K,GACA,GAAAkE,GAAAnL,KAAAmL,OAEA,OAAAnD,SAAAI,UACAW,KAAA,WAKA,MAJA6B,GAAA6C,EAAA,gBACA7C,EAAAkH,EAAA,eACAlH,EAAAmH,EAAA,aAEA3H,EAAAqD,EAAA,eAt+CA,MAw+CA1E,KAAA,SAAAsC,GACA,GAAAW,IACA8F,cACAC,aAEA5F,IAkBA,OAhBAlF,KACAA,EAAAuF,OACAL,EAAA3C,SACAiD,kBAAAxF,EAAAuF,OAIAvF,EAAA+K,WACAhG,EAAAgG,SAAA/K,EAAA+K,UAGA/K,EAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,kBAIAc,EAAA7D,KAAA,cAAA+D,EAAAW,EAAAG,MAYArB,EAAAvJ,UAAA0Q,UAAA,SAAAxE,EAAAxG,GACA,GAAAkE,GAAAnL,KAAAmL,OAGA,OAFAlE,SAEAe,QAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eAnhDA,MAqhDA1E,KAAA,SAAAsC,GACA,GAAA6G,GAAA,aAIA,OAHAjL,GAAAkL,UACAD,GAAA,YAAA7M,mBAAA4B,EAAAkL,UAEAhH,EAAA7D,KAAA4K,EAAA,MAAA7G,MAaAP,EAAAvJ,UAAA6Q,kBAAA,SAAAnJ,EAAAoJ,EAAAC,EAAAf,GACA,GAAAxR,GAAAC,IAEA,OAAAgI,SAAAI,UACAW,KAAA,WAKA,MAJA6B,GAAA3B,EAAA,QACA2B,EAAAyH,EAAA,UACAzH,EAAA0H,EAAA,iBAEAvS,EAAAoL,QAAA7D,KAAA,oCACA2B,OACAoB,gBACAkH,WACAc,SACAC,sBAYAxH,EAAAvJ,UAAAgR,eAAA,SAAA9E,GACA,GAAAtC,GAAAnL,KAAAmL,OAEA,OAAAnD,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eAxkDA,MA0kDA1E,KAAA,SAAAsC,GACA,MAAAF,GAAA7D,KAAA,yBAAA+D,MAWAP,EAAAvJ,UAAAiR,oBAAA,SAAA/E,EAAA7B,GACA,GAAAT,GAAAnL,KAAAmL,OAEA,OAAAnD,SAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAA6C,EAAA,gBACA7C,EAAA6C,EAAA,SAEArD,EAAAqD,EAAA,eA9lDA,MAgmDA1E,KAAA,SAAAsC,GAKA,MAAAF,GAAA7D,KAAA,yBAAA+D,GAHAO,aAcAd,EAAAvJ,UAAAkR,qBAAA,SAAAhF,EAAA7B,GACA,GAAAT,GAAAnL,KAAAmL,OAEA,OAAAnD,SAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAA6C,EAAA,gBACA7C,EAAA6C,EAAA,SAEArD,EAAAqD,EAAA,eAxnDA,MA0nDA1E,KAAA,SAAAsC,GAKA,MAAAF,GAAA7D,KAAA,iCAAA+D,GAHAO,aAcAd,EAAAvJ,UAAAmR,6BAAA,SAAAjF,EAAA7B,GACA,GAAAT,GAAAnL,KAAAmL,OACA,OAAAnD,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eAhpDA,MAkpDA1E,KAAA,SAAAsC,GAIA,MAAAF,GAAA7D,KAAA,qCAAA+D,GAFAO,aAqBAd,EAAAvJ,UAAAoR,gBAAA,SAAAlF,EAAAxG,GACA,GAAAkE,GAAAnL,KAAAmL,OACA,OAAAnD,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eA/qDA,MAirDA1E,KAAA,SAAAsC,GACA,GAAAW,KAMA,OAJA/E,MAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,iBAGAc,EAAA7D,KAAA,sBAAA+D,EAAAW,MAUAlB,EAAAvJ,UAAAqR,gBAAA,SAAAnF,GACA,GAAAtC,GAAAnL,KAAAmL,OACA,OAAAnD,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eAxsDA,MA0sDA1E,KAAA,SAAAsC,GACA,MAAAF,GAAA7D,KAAA,uBAAA+D,SAWAP,EAAAvJ,UAAAsR,qBAAA,SAAApF,GACA,GAAAtC,GAAAnL,KAAAmL,OACA,OAAAnD,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eA5tDA,MA8tDA1E,KAAA,SAAAsC,GACA,MAAAF,GAAA7D,KAAA,qBAAA+D,MAoBAP,EAAAvJ,UAAAuR,eAAA,SAAArF,EAAAxE,EAAAhC,GACA,GAAAkE,GAAAnL,KAAAmL,OACA,OAAAnD,SAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAA6C,EAAA,gBACA7C,EAAA3B,EAAA,QAEAmB,EAAAqD,EAAA,eA1vDA,MA4vDA1E,KAAA,SAAAsC,GACA,GAAAW,IACA/C,OAOA,OAJAhC,MAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,iBAGAc,EAAA7D,KAAA,8BAAA+D,EAAAW,MAUAlB,EAAAvJ,UAAAwR,qBAAA,SAAAtF,GACA,GAAAtC,GAAAnL,KAAAmL,OACA,OAAAnD,SAAAI,UACAW,KAAA,WAGA,MAFA6B,GAAA6C,EAAA,gBAEArD,EAAAqD,EAAA,eArxDA,MAuxDA1E,KAAA,SAAAsC,GAEA,MAAAF,GAAA7D,KAAA,uBAAA+D,MAoBAP,EAAAvJ,UAAAyR,oBAAA,SAAAvF,EAAAxE,EAAAhC,GACA,GAAAkE,GAAAnL,KAAAmL,OACA,OAAAnD,SAAAI,UACAW,KAAA,WAIA,MAHA6B,GAAA6C,EAAA,gBACA7C,EAAA3B,EAAA,QAEAmB,EAAAqD,EAAA,eApzDA,MAszDA1E,KAAA,SAAAsC,GACA,GAAAW,IACA/C,OAOA,OAJAhC,MAAAoD,iBACA2B,EAAA3B,iBAAAqC,SAAAzF,EAAAoD,iBAGAc,EAAA7D,KAAA,sCAAA+D,EAAAW,MAWAlB,EAAAvJ,UAAA0R,UAAArI,EAEAE,GACCnE,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,IN+TK,SAAUhC,EAAQD,EAASO,IAEL,SAASgT,IOzpErC,SAAAA,EAAAxT,GACAE,EAAAD,QAAAD,KAGCM,EAAA,WAAqB,YAEtB,SAAAmT,GAAAC,GACA,GAAA9F,SAAA8F,EACA,eAAAA,IAAA,WAAA9F,GAAA,aAAAA,GAGA,QAAA+F,GAAAD,GACA,wBAAAA,GAkCA,QAAAE,GAAAC,GACAC,EAAAD,EAGA,QAAAE,GAAAC,GACAC,EAAAD,EAqBA,QAAAE,KACA,gBAAAC,EACA,WACAA,EAAAC,IAIAC,IAuBA,QAAAA,KAGA,GAAAC,GAAAC,UACA,mBACA,MAAAD,GAAAF,EAAA,IAKA,QAAAA,KACA,OAAAzT,GAAA,EAAiB6T,EAAA7T,EAASA,GAAA,IAI1B8T,EAHAC,EAAA/T,IACA+T,EAAA/T,EAAA,IAIA+T,EAAA/T,OAAAwB,GACAuS,EAAA/T,EAAA,OAAAwB,GAGAqS,EAAA,EA4BA,QAAAnL,GAAAsL,EAAAC,GACA,GAAAC,GAAAC,UAEAC,EAAAzU,KAEA0U,EAAA,GAAA1U,MAAA2U,YAAAC,OAEA/S,KAAA6S,EAAAG,IACAC,EAAAJ,EAGA,IAAAK,GAAAN,EAAAM,MAaA,OAXAA,GACA,WACA,GAAAZ,GAAAI,EAAAQ,EAAA,EACApB,GAAA,WACA,MAAAqB,GAAAD,EAAAL,EAAAP,EAAAM,EAAAQ,cAIAC,EAAAT,EAAAC,EAAAL,EAAAC,GAGAI,EAkCA,QAAAS,GAAA9T,GAEA,GAAA+T,GAAApV,IAEA,IAAAqB,GAAA,gBAAAA,MAAAsT,cAAAS,EACA,MAAA/T,EAGA,IAAAgU,GAAA,GAAAD,GAAAR,EAEA,OADAxM,GAAAiN,EAAAhU,GACAgU,EAKA,QAAAT,MAQA,QAAAU,KACA,UAAAC,WAAA,4CAGA,QAAAC,KACA,UAAAD,WAAA,wDAGA,QAAAE,GAAAJ,GACA,IACA,MAAAA,GAAAtM,KACG,MAAAb,GAEH,MADAwN,IAAAxN,QACAwN,IAIA,QAAAC,GAAAC,EAAAC,EAAAC,EAAAC,GACA,IACAH,EAAArV,KAAAsV,EAAAC,EAAAC,GACG,MAAA1T,GACH,MAAAA,IAIA,QAAA2T,GAAAX,EAAAY,EAAAL,GACAjC,EAAA,SAAA0B,GACA,GAAAa,IAAA,EACAhO,EAAAyN,EAAAC,EAAAK,EAAA,SAAAJ,GACAK,IAGAA,GAAA,EACAD,IAAAJ,EACAzN,EAAAiN,EAAAQ,GAEAM,EAAAd,EAAAQ,KAEK,SAAA/I,GACLoJ,IAGAA,GAAA,EAEAjO,EAAAoN,EAAAvI,KACK,YAAAuI,EAAAe,QAAA,sBAELF,GAAAhO,IACAgO,GAAA,EACAjO,EAAAoN,EAAAnN,KAEGmN,GAGH,QAAAgB,GAAAhB,EAAAY,GACAA,EAAAlB,SAAAuB,GACAH,EAAAd,EAAAY,EAAAhB,SACGgB,EAAAlB,SAAAwB,GACHtO,EAAAoN,EAAAY,EAAAhB,SAEAC,EAAAe,MAAApU,GAAA,SAAAgU,GACA,MAAAzN,GAAAiN,EAAAQ,IACK,SAAA/I,GACL,MAAA7E,GAAAoN,EAAAvI,KAKA,QAAA0J,GAAAnB,EAAAoB,EAAAb,GACAa,EAAA9B,cAAAU,EAAAV,aAAAiB,IAAA7M,GAAA0N,EAAA9B,YAAAvM,UAAA+M,EACAkB,EAAAhB,EAAAoB,GAEAb,IAAAF,IACAzN,EAAAoN,EAAAK,GAAAxN,OACAwN,GAAAxN,MAAA,UACKrG,KAAA+T,EACLO,EAAAd,EAAAoB,GACKpD,EAAAuC,GACLI,EAAAX,EAAAoB,EAAAb,GAEAO,EAAAd,EAAAoB,GAKA,QAAArO,GAAAiN,EAAAQ,GACAR,IAAAQ,EACA5N,EAAAoN,EAAAC,KACGnC,EAAA0C,GACHW,EAAAnB,EAAAQ,EAAAJ,EAAAI,IAEAM,EAAAd,EAAAQ,GAIA,QAAAa,GAAArB,GACAA,EAAAsB,UACAtB,EAAAsB,SAAAtB,EAAAJ,SAGA2B,EAAAvB,GAGA,QAAAc,GAAAd,EAAAQ,GACAR,EAAAN,SAAA8B,KAIAxB,EAAAJ,QAAAY,EACAR,EAAAN,OAAAuB,GAEA,IAAAjB,EAAAyB,aAAA7U,QACA0R,EAAAiD,EAAAvB,IAIA,QAAApN,GAAAoN,EAAAvI,GACAuI,EAAAN,SAAA8B,KAGAxB,EAAAN,OAAAwB,GACAlB,EAAAJ,QAAAnI,EAEA6G,EAAA+C,EAAArB,IAGA,QAAAH,GAAAT,EAAAC,EAAAL,EAAAC,GACA,GAAAwC,GAAArC,EAAAqC,aACA7U,EAAA6U,EAAA7U,MAEAwS,GAAAkC,SAAA,KAEAG,EAAA7U,GAAAyS,EACAoC,EAAA7U,EAAAqU,IAAAjC,EACAyC,EAAA7U,EAAAsU,IAAAjC,EAEA,IAAArS,GAAAwS,EAAAM,QACApB,EAAAiD,EAAAnC,GAIA,QAAAmC,GAAAvB,GACA,GAAA0B,GAAA1B,EAAAyB,aACAE,EAAA3B,EAAAN,MAEA,QAAAgC,EAAA9U,OAAA,CAQA,OAJAyS,OAAA7S,GACAsS,MAAAtS,GACAoV,EAAA5B,EAAAJ,QAEA5U,EAAA,EAAiB0W,EAAA9U,OAAA5B,EAAwBA,GAAA,EACzCqU,EAAAqC,EAAA1W,GACA8T,EAAA4C,EAAA1W,EAAA2W,GAEAtC,EACAM,EAAAgC,EAAAtC,EAAAP,EAAA8C,GAEA9C,EAAA8C,EAIA5B,GAAAyB,aAAA7U,OAAA,GAGA,QAAAiV,KACAlX,KAAAkI,MAAA,KAKA,QAAAiP,GAAAhD,EAAA8C,GACA,IACA,MAAA9C,GAAA8C,GACG,MAAA5U,GAEH,MADA+U,IAAAlP,MAAA7F,EACA+U,IAIA,QAAApC,GAAAgC,EAAA3B,EAAAlB,EAAA8C,GACA,GAAAI,GAAAhE,EAAAc,GACA0B,MAAAhU,GACAqG,MAAArG,GACAyV,MAAAzV,GACA0V,MAAA1V,EAEA,IAAAwV,GAWA,GAVAxB,EAAAsB,EAAAhD,EAAA8C,GAEApB,IAAAuB,IACAG,GAAA,EACArP,EAAA2N,EAAA3N,MACA2N,EAAA3N,MAAA,MAEAoP,GAAA,EAGAjC,IAAAQ,EAEA,WADA5N,GAAAoN,EAAAG,SAIAK,GAAAoB,EACAK,GAAA,CAGAjC,GAAAN,SAAA8B,KAEGQ,GAAAC,EACHlP,EAAAiN,EAAAQ,GACK0B,EACLtP,EAAAoN,EAAAnN,GACK8O,IAAAV,GACLH,EAAAd,EAAAQ,GACKmB,IAAAT,IACLtO,EAAAoN,EAAAQ,IAIA,QAAA2B,GAAAnC,EAAAoC,GACA,IACAA,EAAA,SAAA5B,GACAzN,EAAAiN,EAAAQ,IACK,SAAA/I,GACL7E,EAAAoN,EAAAvI,KAEG,MAAAzK,GACH4F,EAAAoN,EAAAhT,IAKA,QAAAqV,KACA,MAAAhH,MAGA,QAAAoE,GAAAO,GACAA,EAAAR,GAAAnE,KACA2E,EAAAN,WAAAlT,GACAwT,EAAAJ,YAAApT,GACAwT,EAAAyB,gBAGA,QAAAa,GAAAvC,EAAAwC,GACA5X,KAAA6X,qBAAAzC,EACApV,KAAAqV,QAAA,GAAAD,GAAAR,GAEA5U,KAAAqV,QAAAR,IACAC,EAAA9U,KAAAqV,SAGAyC,EAAAF,IACA5X,KAAAiC,OAAA2V,EAAA3V,OACAjC,KAAA+X,WAAAH,EAAA3V,OAEAjC,KAAAiV,QAAA+C,MAAAhY,KAAAiC,QAEA,IAAAjC,KAAAiC,OACAkU,EAAAnW,KAAAqV,QAAArV,KAAAiV,UAEAjV,KAAAiC,OAAAjC,KAAAiC,QAAA,EACAjC,KAAAiY,WAAAL,GACA,IAAA5X,KAAA+X,YACA5B,EAAAnW,KAAAqV,QAAArV,KAAAiV,WAIAhN,EAAAjI,KAAAqV,QAAA6C,KAIA,QAAAA,KACA,MAAArN,OAAA,2CA8GA,QAAAsN,GAAAC,GACA,UAAAT,GAAA3X,KAAAoY,GAAA/C,QAoEA,QAAAgD,GAAAD,GAEA,GAAAhD,GAAApV,IAEA,OAKA,IAAAoV,GALA0C,EAAAM,GAKA,SAAAhQ,EAAAH,GAEA,OADAhG,GAAAmW,EAAAnW,OACA5B,EAAA,EAAqB4B,EAAA5B,EAAYA,IACjC+U,EAAAhN,QAAAgQ,EAAA/X,IAAA0I,KAAAX,EAAAH,IAPA,SAAAqQ,EAAArQ,GACA,MAAAA,GAAA,GAAAsN,WAAA,sCA8CA,QAAAgD,GAAAzL,GAEA,GAAAsI,GAAApV,KACAqV,EAAA,GAAAD,GAAAR,EAEA,OADA3M,GAAAoN,EAAAvI,GACAuI,EAGA,QAAAmD,KACA,SAAAjD,WAAA,sFAGA,QAAAkD,KACA,SAAAlD,WAAA,yHA0GA,QAAAmD,GAAAjB,GACAzX,KAAA6U,GAAA6C,IACA1X,KAAAiV,QAAAjV,KAAA+U,WAAAlT,GACA7B,KAAA8W,gBAEAlC,IAAA6C,IACA,kBAAAA,IAAAe,IACAxY,eAAA0Y,GAAAlB,EAAAxX,KAAAyX,GAAAgB,KAmPA,QAAAE,KACA,GAAAC,OAAA/W,EAEA,aAAAqR,EACA0F,EAAA1F,MACK,uBAAAnT,MACL6Y,EAAA7Y,SAEA,KACA6Y,EAAAC,SAAA,iBACS,MAAAxW,GACT,KAAAwI,OAAA,4EAIA,GAAAiO,GAAAF,EAAA5Q,OAEA,IAAA8Q,EAAA,CACA,GAAAC,GAAA,IACA,KACAA,EAAAjY,OAAAS,UAAAgC,SAAAhD,KAAAuY,EAAA1Q,WACS,MAAA/F,IAIT,wBAAA0W,IAAAD,EAAAE,KACA,OAIAJ,EAAA5Q,QAAA0Q,EAlmCA,GAAAO,OAAApX,EAEAoX,GADAjB,MAAAF,QACAE,MAAAF,QAEA,SAAA1E,GACA,yBAAAtS,OAAAS,UAAAgC,SAAAhD,KAAA6S,GAIA,IAAA0E,GAAAmB,EAEA/E,EAAA,EACAL,MAAAhS,GACA2R,MAAA3R,GAEA8R,EAAA,SAAAQ,EAAA+E,GACA9E,EAAAF,GAAAC,EACAC,EAAAF,EAAA,GAAAgF,EAEA,KADAhF,GAAA,KAKAV,EACAA,EAAAM,GAEAqF,MAaAC,EAAA,mBAAAC,mBAAAxX,GACAyX,EAAAF,MACAG,EAAAD,EAAAE,kBAAAF,EAAAG,uBACAC,EAAA,mBAAA3Z,OAAA,mBAAA4Z,UAAiF,wBAAApW,SAAAhD,KAAAoZ,SAGjFC,EAAA,mBAAAC,oBAAA,mBAAAC,gBAAA,mBAAAC,gBAmDA3F,EAAA4D,MAAA,KA0BAmB,MAAAtX,EAGAsX,GADAO,EA5EA,WAGA,kBACA,MAAAC,SAAAK,SAAAlG,OA0ECyF,EA3DD,WACA,GAAAU,GAAA,EACAC,EAAA,GAAAX,GAAAzF,GACAqG,EAAAC,SAAAC,eAAA,GAGA,OAFAH,GAAAI,QAAAH,GAA0BI,eAAA,IAE1B,WACAJ,EAAAnO,KAAAiO,MAAA,MAsDCL,EAjDD,WACA,GAAAY,GAAA,GAAAT,eAEA,OADAS,GAAAC,MAAAC,UAAA5G,EACA,WACA,MAAA0G,GAAAG,MAAAC,YAAA,WA+CC/Y,KAAAuX,EAnBD,WACA,IACA,GACAyB,GAAA3a,EAAA,EAEA,OADA2T,GAAAgH,EAAAC,WAAAD,EAAAE,aACAnH,IACG,MAAAvR,GACH,MAAA0R,SAeAA,GA0EA,IAAAc,GAAA3Q,KAAA8W,SAAAzX,SAAA,IAAA0X,UAAA,IAIApE,OAAA,GACAP,GAAA,EACAC,GAAA,EAEAb,GAAA,GAAAwB,GA6KAE,GAAA,GAAAF,GA+DAxG,GAAA,CAsqBA,OA1nBAiH,GAAApW,UAAA0W,WAAA,SAAAL,GACA,OAAAvX,GAAA,EAAiBL,KAAA+U,SAAA8B,IAAAe,EAAA3V,OAAA5B,EAA6CA,IAC9DL,KAAAkb,WAAAtD,EAAAvX,OAIAsX,EAAApW,UAAA2Z,WAAA,SAAAC,EAAA9a,GACA,GAAAI,GAAAT,KAAA6X,qBACAuD,EAAA3a,EAAA2H,OAEA,IAAAgT,IAAAjG,EAAA,CACA,GAAAkG,GAAA5F,EAAA0F,EAEA,IAAAE,IAAAtS,GAAAoS,EAAApG,SAAA8B,GACA7W,KAAAsb,WAAAH,EAAApG,OAAA1U,EAAA8a,EAAAlG,aACK,sBAAAoG,GACLrb,KAAA+X,aACA/X,KAAAiV,QAAA5U,GAAA8a,MACK,IAAA1a,IAAAiY,EAAA,CACL,GAAArD,GAAA,GAAA5U,GAAAmU,EACA4B,GAAAnB,EAAA8F,EAAAE,GACArb,KAAAub,cAAAlG,EAAAhV,OAEAL,MAAAub,cAAA,GAAA9a,GAAA,SAAA2a,GACA,MAAAA,GAAAD,KACO9a,OAGPL,MAAAub,cAAAH,EAAAD,GAAA9a,IAIAsX,EAAApW,UAAA+Z,WAAA,SAAAE,EAAAnb,EAAAwV,GACA,GAAAR,GAAArV,KAAAqV,OAEAA,GAAAN,SAAA8B,KACA7W,KAAA+X,aAEAyD,IAAAjF,GACAtO,EAAAoN,EAAAQ,GAEA7V,KAAAiV,QAAA5U,GAAAwV,GAIA,IAAA7V,KAAA+X,YACA5B,EAAAd,EAAArV,KAAAiV,UAIA0C,EAAApW,UAAAga,cAAA,SAAAlG,EAAAhV,GACA,GAAAob,GAAAzb,IAEAkV,GAAAG,MAAAxT,GAAA,SAAAgU,GACA,MAAA4F,GAAAH,WAAAhF,GAAAjW,EAAAwV,IACG,SAAA/I,GACH,MAAA2O,GAAAH,WAAA/E,GAAAlW,EAAAyM,MA8SA4L,EAAAvI,IAAAgI,EACAO,EAAAgD,KAAArD,EACAK,EAAAtQ,QAAA+M,EACAuD,EAAAzQ,OAAAsQ,EACAG,EAAAiD,cAAArI,EACAoF,EAAAkD,SAAAnI,EACAiF,EAAAmD,MAAAlI,EAEA+E,EAAAnX,WACAoT,YAAA+D,EAmMA3P,OA6BA+S,MAAA,SAAAxH,GACA,MAAAtU,MAAA+I,KAAA,KAAAuL,KAuCAoE,EAAAjN,SAAAkN,EACAD,EAAA1Q,QAAA0Q,EAEAA,MPuqE6BnY,KAAKZ,EAASO,EAAoB,KAIzD,SAAUN,GQ3yGhB,GAAA0C,EAGAA,GAAA,WACA,MAAAtC,QAGA,KAEAsC,KAAAuW,SAAA,qBAAAkD,MAAA,QACC,MAAA1Z,GAED,gBAAAgX,UACA/W,EAAA+W,QAOAzZ,EAAAD,QAAA2C,GRkzGM,aAMA,SAAU1C,EAAQD,EAASO,GS50GjC,GAAAyB,GAAAC,CAGAD,IAAAzB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,SAuJC2B,MAvJDD,EAAA,SAAAkF,EAAA5E,EAAAwH,EAAAhD,GACA,YAkBA,SAAAsV,GAAArb,GACA,MAAAuB,GAAAmB,MAAAwB,WAAAM,OAAA8W,EAAAtb,GAYA,QAAAub,GAAAvb,EAAAiL,GACA,MAAA1J,GAAAmB,MAAAwB,WAAAM,OAAA8W,EAAAtb,EAAA,IAAAiL,GA7BA,GAAAqQ,GAAA,gCAIAE,EAAAja,EAAAmB,MAAAkC,IAAAJ,OAAA,KAgCA,QASA2G,MAAA,SAAAsQ,EAAAC,GACA,GAAA9T,MACAqD,EAAAsQ,EAAA,eAAAE,GACAvQ,EAAA3J,EAAAmB,MAAAwB,WAAAM,OAAAkX,EAKA,OAHA9T,GAAA0D,UAAAmQ,EACA7T,EAAA+T,aAAAD,EAEA3V,EAAA6V,OAAA1Q,EAAAD,EApDA,IACA,KAoDA7C,KACA,SAAAyT,GAGA,MAFAjU,GAAAiU,mBAEA9S,EAAA8S,EAAAR,EAAA,UAAAG,EArDA,IAsDApT,KACA,SAAAmD,GAGA,MAFA3D,GAAA2D,SAEAxC,EAAA8S,EAAAR,EAAA,cAAAG,EA1DA,QA+DApT,KACA,SAAA6D,GAEA,MADArE,GAAAqE,aACArE,KAYAmG,IAAA,SAAA+N,EAAAC,GAGA,OAFAnU,MAEAlI,EAAA,EAAqBoc,EAAAxa,OAAA5B,EAAsBA,IAC3CkI,EAAAlI,GAAAoc,EAAApc,GAAAqc,EAAArc,EAGA,OAAAkI,IAQAgG,yBAAA,SAAAoO,EAAAnO,GACA,GAAAzO,GAAAC,KACA4c,EAAA1a,EAAAmB,MAAAkC,IAAAJ,OAAAqJ,EAEA,OAAAxO,MAAA6c,iBAAAF,EAAA,gBACA5T,KACA,SAAA2B,GACA,GAAAoS,GAAA5a,EAAA4B,SAAAC,SAAA6Y,EAAA,OACAG,EAAA7a,EAAA4B,SAAAC,SAAA6Y,GAAA,KACAtW,EAAA,GAAApE,GAAAkB,KAAAkD,KAAAoE,EAAAsS,QAAA9a,EAAAe,KAAA8C,OAGA,IAFAO,EAAAL,OAAA6W,IAEA5a,EAAA4B,SAAAY,MAAA4B,EAAAG,SAAAsW,GACA,KAAAlS,OAAA,WAGA,IAAAoS,GAAAld,EAAA2O,IAAAxM,EAAA4B,SAAAC,SAAA6Y,EAAA,OAAAlS,EAAAwS,OAEA,QACAtO,GAAA1M,EAAAmB,MAAAkC,IAAAT,SAAA5C,EAAA4B,SAAAC,SAAAkZ,EAAA,QACAtO,OAAAzM,EAAAmB,MAAAkC,IAAAT,SAAA5C,EAAA4B,SAAAC,SAAAkZ,EAAA,UAWAJ,iBAAA,SAAAF,EAAAQ,GACA,GAAAC,GAAApB,EAAAmB,GACAtT,EAAA3H,EAAAmB,MAAAkC,IAAAJ,OAAA,GAGA,OAFAwX,GAAAza,EAAAmB,MAAAkC,IAAAJ,OAAAwX,GAEAjT,EAAAiT,EAAAS,EAAAvT,EAAA,IACAd,KACA,SAAAsU,GAEA,OACAL,QAAA9a,EAAA4B,SAAAC,SAAAsZ,EAAA,OACAH,OAAAhb,EAAA4B,SAAAC,SAAAsZ,EAAA,WAOC1W,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,ITo1GK,SAAUhC,EAAQD,EAASO,GU9+GjC,GAAAyB,GAAAC,CAGAD,IAAAzB,EAAA,QA2fC2B,MA3fDD,EAAA,SAAAM,GACA,YAWA,IAAA0E,KA8eA,OA5eAA,GAAAuC,QA+BAC,OAAA,SAAAzB,EAAAH,EAAAP,GAEA,GAAAsB,IACAgB,MAAA,GACA+T,aAKA,KAAA3V,GAAA,gBAAAA,IAAA,gBAAAA,KACAH,GAAA,gBAAAA,KACAP,GAAA,gBAAAA,GAGA,MADAsB,GAAAgV,IAAA,wBACAhV,CAKA,IAAAiV,GAAAvW,EAAAuW,WAAAtZ,KAAAC,OAAAyC,EAAA6W,MAAAC,OAAAzW,EAAAE,qBAAA,SAIAM,EAAAR,EAAAQ,WACA,MAAAA,GACAA,EAAAiJ,IACAjJ,EAAAkV,KACAlV,EAAAkW,WAGA,MADApV,GAAAgV,IAAA,4BACAhV,CAGA,SAAA3B,EAAA6W,MAAAG,YAAAhX,EAAAiX,OAAAC,WAAArW,EAAAkW,WAEA,MADApV,GAAAgV,IAAA,oBACAhV,CAKA,iBAAAZ,KACAA,EAAAf,EAAA6W,MAAAM,SAAApW,GAKA,IAAA2V,IACAU,GAAAR,EACAS,MAAAhX,EAAAgX,OAAArX,EAAA6W,MAAAS,aAAA,GACA1W,SACA2W,SAAAxW,EAAAyW,SACAC,KAAA1W,EAAA2W,SACAC,KAAA5W,EAAA4W,KACAtb,KAAAgE,EAAAhE,KACAub,IAAAvX,EAAAuX,IACAC,IAAAxX,EAAAwX,IACAC,IAAAzX,EAAAyX,IAGAnW,GAAA+U,aAIAA,EAAAra,MACAgE,EAAAzF,eAAA,aAEA8b,EAAAra,KAAA2D,EAAAiX,OAAAc,qBAAA1X,EAAAW,QAAAH,EAAAkW,UAAA1W,EAAAoC,aAGA,IAAA7C,GAAAI,EAAAiX,OAAAe,aAAA,SAAAnX,EAAA6V,GAIAuB,EAAA,OAAAvB,EAAAkB,SAAA3c,KAAAyb,EAAAkB,KAAA,KAAAlB,EAAAkB,IACApV,EAAA,YAAA3B,EAAAiJ,GACA,UAAA4M,EAAAU,GACA,aAAAV,EAAAW,OACAX,EAAAra,KAAA,YAAAqa,EAAAra,KAAA,KACA4b,EAAA,WAAAjY,EAAA6W,MAAAqB,sBAAAxB,EAAAkB,KAAA,IACA,WAAAhY,EAAA,GASA,OAPA8W,GAAAmB,MACArV,GAAA,UAAAkU,EAAAmB,KACAnB,EAAAoB,IAAA,WAAApB,EAAAoB,IAAA,SAGAnW,EAAAgB,MAAAH,EAEAb,GAeAwW,aAAA,SAAA5T,EAAA1D,EAAA6V,EAAArW,GAIA,GAFAA,QAEAkE,EAAA6T,kBAAA,qBAIA,GAAAC,GAAArY,EAAA6W,MAAAyB,yBAAA/T,EAAA6T,kBAAA,yCACA,KAAAC,EACA,QAGA,IAAAA,EAAAjB,GAAA,CAEA,GADApX,EAAAiX,OAAAsB,eAAAF,EAAAjB,GAAAvW,KACAwX,EAAAG,IACA,QAGAxY,GAAA6W,MAAA4B,aAAAJ,EAAAjB,GAAA9Z,KAAAC,OAAA,GAAA0E,OAAAC,UAAA,OAMA,IAAAqC,EAAA6T,kBAAA,0BACA/X,EAAA2D,SAEA,QAGA,IAAA0U,GAAA1Y,EAAA6W,MAAAyB,yBAAA/T,EAAA6T,kBAAA,6CACA,SAAAM,IAiBA1Y,EAAAiX,OAAAe,aAAA,WAAAnX,GAZAuW,GAAAV,EAAAU,GACAC,MAAAX,EAAAW,MACAzW,OAAA8V,EAAA9V,OACA2W,SAAAb,EAAAa,SACAE,KAAAf,EAAAe,KACAE,KAAAjB,EAAAiB,KACAtb,KAAAqc,EAAArc,KACAub,IAAAc,EAAAd,IACAC,IAAAnB,EAAAmB,IACAC,IAAApB,EAAAoB,QAIAY,EAAA9Y,OAIAS,EAAAzF,eAAA,cAIA8d,EAAArc,MAIA2D,EAAAiX,OAAAc,qBAAA1X,EAAAW,QAAAH,EAAAkW,UAAAxS,EAAA6T,kBAAA,mBACAM,EAAArc,QAGAO,QAAA,SAAA6a,EAAAE,EAAA/a,EAAAyD,GAIA,IAAAoX,GAAA,gBAAAA,KACAE,GAAA,gBAAAA,IACA,OAAA/a,OAAA3B,KAAA2B,GAAA,gBAAAA,KACAyD,GAAA,gBAAAA,GAEA,WAKA,IAAAuW,GAAAvW,EAAAuW,WAAAtZ,KAAAC,OAAAyC,EAAA6W,MAAAC,OAAAzW,EAAAE,qBAAA,SAIAM,EAAAR,EAAAQ,WACA,MAAAA,GACAA,EAAAiJ,IACAjJ,EAAAkV,KACAlV,EAAAkW,WAGA,WAGA,SAAA/W,EAAAiX,OAAAC,WAAAjY,QAAA4B,EAAAkW,WACA,WAKA,IAAAL,IACAU,GAAAR,EACAS,MAAAhX,EAAAgX,OAAArX,EAAA6W,MAAAS,aAAA,GACAG,OACAE,OACAtb,KAAA2D,EAAAiX,OAAAc,qBAAAnb,EAAAiE,EAAAkW,WAaA,QAPAjN,GAAAjJ,EAAAiJ,GACAsN,GAAAV,EAAAU,GACAC,MAAAX,EAAAW,MACAhb,KAAAqa,EAAAra,KACAuD,IAAAI,EAAAiX,OAAAe,aAAA,UAAAnX,EAAA6V,KAMAiC,sBAAA,SAAA/b,EAAAiE,EAAA+X,GAGA,MADA5Y,GAAAiX,OAAAsB,eAAA3b,EAAAwa,GAAAvW,KACAjE,EAAA4b,OAIA,IAAAI,GACA5Y,EAAA6W,MAAA4B,aAAA7b,EAAAwa,GAAA9Z,KAAAC,OAAA,GAAA0E,OAAAC,UAAA,OAGA,KAKAlC,EAAAiX,QAEA4B,cAAA,IAEA3B,YAAA,iBAEAc,aAAA,SAAAtR,EAAA7F,EAAAR,GACA,GAAAyY,GAAA9Y,EAAAiX,OAAA8B,yBAAArS,EAAArG,GACAX,EAAA,GAAApE,GAAAkB,KAAAkD,KAAAmB,EAAAkV,IAAAza,EAAAe,KAAA8C,OAGA,OAFAO,GAAAL,OAAAyZ,GAEAxd,EAAAmB,MAAAsC,OAAAb,SAAAwB,EAAAG,WAGAkZ,yBAAA,SAAArS,EAAArG,GAEA,GAAAyY,GAAA,QAAA9Y,EAAAiX,OAAA4B,cAAA,IAAAnS,EAAA,KACArG,EAAA+W,GAAA,KACA/W,EAAAgX,MAAA,MACAhX,EAAAO,QAAA,IAAAoY,cAAA,MACA3Y,EAAAkX,UAAA,SACAlX,EAAAoX,KAAAwB,cAAA,KACA5Y,EAAAsX,KAAA,MACAtX,EAAAhE,MAAA,QAaA,OAXAgE,GAAAuX,MACAkB,GAAAzY,EAAAuX,IAAA/Y,QAAA,aAAAA,QAAA,aAGAia,GAAA,KAEAzY,EAAAwX,MACAiB,GAAAzY,EAAAwX,IAAA,MACAxX,EAAAyX,KAAA,UAGAgB,GAGAf,qBAAA,SAAA/W,EAAA+V,EAAAtU,GACA,GAAApG,GAAA,GAAAf,GAAAe,KAAA8C,MAMA,OALA9C,GAAAgD,OAAA,QAAAW,EAAAiX,OAAA4B,cAAA,cACAxZ,OAAAW,EAAA6W,MAAAqC,iBAAAzW,GAAA,MACApD,OAAA2B,GAAA,IACA3B,OAAA,MAEA/D,EAAAmB,MAAAsC,OAAAb,SAAA7B,EAAAiD,aAGAiZ,eAAA,SAAAnB,EAAAvW,GACA,GAAAnB,GAAA,GAAApE,GAAAkB,KAAAkD,KAAAmB,EAAAkV,IAAAza,EAAAe,KAAA8C,OAGA,OAFAO,GAAAL,OAAA,QAAAW,EAAAiX,OAAA4B,cAAA,QAAAzB,EAAA,MAEA9b,EAAAmB,MAAAsC,OAAAb,SAAAwB,EAAAG,YAKAG,EAAA6W,OAEAsC,SACAC,UACAC,QAAA,SAAAtD,EAAA9G,GAEAjP,EAAA6W,MAAAsC,QAAAC,OAAArD,GAAA9G,GAEAqK,QAAA,SAAAvD,GAEA,MAAA/V,GAAA6W,MAAAsC,QAAAC,OAAArD,KAIAwD,WAAA,SAAAJ,GAEA,GAAAK,GAAAxZ,EAAA6W,MAAA4C,gBAAA,CACAzZ,GAAA6W,MAAAsC,UACAnZ,EAAA6W,MAAA4B,aAAAe,IAGAf,aAAA,SAAAiB,GAEA,IACA1Z,EAAA6W,MAAAsC,QAAAE,QAAA,kBAAAK,GAEA,MAAA/C,MAMA8C,aAAA,WAEA,MAAA3a,UAAAkB,EAAA6W,MAAAsC,QAAAG,QAAA,6BAGAxC,IAAA,WAEA,UAAA7U,OAAAC,UAAAlC,EAAA6W,MAAA4C,gBAGAvB,sBAAA,SAAAyB,GAEA,MAAAA,GAAA9a,QAAA,cAAAA,QAAA,cAGAqa,iBAAA,SAAA1W,GAEA,MAAAA,GAIAA,EAAAoX,MAAA,KAA4B,GAAA/a,QAAA,iBAAAoa,cAH5B,IAMAX,yBAAA,SAAA9V,EAAAsB,GAEA,IAAAtB,EACA,WAGA,IAAAqX,GAAArX,EAAAsX,MAAA,sBACA,KAAAD,EACA,WAIA,aADAA,EAAA,GACAZ,cACA,WAGA,IAAAc,GAAAF,EAAA,EACA,KAAAE,EACA,WAGA,IAAArB,KAyBA,YAxBAqB,EAAAlb,QAAA,2CAAAmb,EAAAC,EAAAC,GAIA,QAAApW,EAAA7E,QAAAgb,IAMyE,OAAzEC,EAAAJ,MAAA,6DAMApB,EAAA9d,eAAAqf,GAKA,MADAvB,GAAAuB,GAAAC,EACA,KAIA,KAGAxB,GAGApB,aAAA,SAAA6C,GAMA,OAJAC,GAAA,iEAGAzY,KACAlI,EAAA,EAAqB0gB,EAAA1gB,IAAUA,EAC/BkI,EAAAlI,GAAA2gB,EAAA9c,KAAAC,MAJA6c,GAIA9c,KAAA8W,UAGA,OAAAzS,GAAA0Y,KAAA,KAGArD,YAAA,SAAAsD,EAAArL,EAAAsL,GAIA,IAHA,GAAAC,IAAAD,GAAA,KACAlf,EAAAif,IAAAjf,OAAA,IAEAmf,EAAAnf,GACA,GAAAif,EAAAE,KAAAvL,EACA,MAAAuL,EAGA,WAGArD,SAAA,SAAAnG,GAcA,IAPA,GAAAlN,IAAA,uJAEA2W,EAAA,4IACAC,EAAAD,EAAAE,KAAA3J,GACAjQ,KAEAtH,EAAA,GACAA,KACAsH,EAAA+C,EAAArK,IAAAihB,EAAAjhB,IAAA,EASA,OANA,QAAAsH,EAAA4W,MACA,KAAA5W,EAAA4W,OAEA5W,EAAA4W,KAAA,SAAA5W,EAAA6Z,SAAA3B,cAAA,eAAAlY,EAAA6Z,SAAA3B,cAAA,UAGAlY,IAKAf,GACCD,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,IVs/GK,SAAUhC,EAAQD,EAASO,GWp/HjC,GAAAyB,GAAAC,CAGAD,IAAAzB,EAAA,QAsBC2B,MAtBDD,EAAA,SAAAM,GACA,YAmBA,QANAqa,OAAA,SAAA3E,EAAA/N,EAAAoQ,EAAA/F,GACA,GAAA3L,GAAArG,EAAAkB,KAAAsD,OAAAkR,EAAA/N,EAAAoQ,EAAA/F,EAAAhS,EAAAkB,KAAAkD,KACA,OAAA0B,SAAAI,QAAAG,MAMC5B,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,IX4/HK,SAAUhC,EAAQD,EAASO,GYrhIjC,GAAAyB,GAAAC,CAGAD,IAAAzB,EAAA,GAAAA,EAAA,QAkCC2B,MAlCDD,EAAA,SAAAM,EAAAwH,GACA,YAcA,SAAA+X,GAAAC,EAAAC,EAAAZ,GACA,GAAAa,GAAA1f,EAAAmB,MAAAkC,IAAAJ,OAAAuc,GACA9X,EAAA1H,EAAAmB,MAAAwB,WAAAM,OAAA0c,EAAAF,EAEA,OAAAjY,GAAAkY,EAAAhY,EAAAC,EAAAkX,GAAA,IACAhY,KAAA,SAAA+Y,GACA,GAAAC,GAAAhe,EAAA+d,EAAA,SACAxT,EAAAvK,EAAA+d,EAAA,IAEA,QACAnE,UAAA,SACAjN,GAAAxO,EAAAmB,MAAAkC,IAAAT,SAAAf,EAAA+d,EAAA,QACAnF,IAAAoF,EACAzT,eAzBA,GAAAuT,GAAA,gCACA9d,EAAA7B,EAAA4B,SAAAC,SACA8F,EAAA3H,EAAAmB,MAAAkC,IAAAJ,OAAA,GA4BA,OAAAsc,IACC9a,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC,IZ6hIK,SAAUhC,EAAQD,GalkIxB,GAAAgC,GAAAC,CAOAD,UAiBCE,MAjBDD,EAAA,WACA,YAEA,QACA8K,SAAA,SAAAV,GACA,OACAuF,SAAAvF,EAAAuF,SACAc,OAAArG,EAAAqG,OACAC,cAAAtG,EAAAsG,cACA0P,YAAAhW,EAAAgW,YACAC,WAAAjW,EAAAiW,WACAC,UAAAlW,EAAAkW,UACAC,UAAAnW,EAAAmW,UACAC,QAAApW,EAAAoW,YAICzb,MAAAhH,EAAAgC,MAAA/B,EAAAD,QAAAiC","file":"fxa-client.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FxAccountClient\"] = factory();\n\telse\n\t\troot[\"FxAccountClient\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FxAccountClient\"] = factory();\n\telse\n\t\troot[\"FxAccountClient\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\"use strict\";var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return\"CORRUPT: \"+this.message};this.message=a},invalid:function(a){this.toString=function(){return\"INVALID: \"+this.message};this.message=a},bug:function(a){this.toString=function(){return\"BUG: \"+this.message};this.message=a},notReady:function(a){this.toString=function(){return\"NOT READY: \"+this.message};this.message=a}}};\n\"undefined\"!==typeof module&&module.exports&&(module.exports=sjcl);\nsjcl.cipher.aes=function(a){this.b[0][0][0]||this.g();var b,c,d,e,g=this.b[0][4],f=this.b[1];b=a.length;var h=1;if(4!==b&&6!==b&&8!==b)throw new sjcl.exception.invalid(\"invalid aes key size\");this.e=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=g[c>>>24]<<24^g[c>>16&255]<<16^g[c>>8&255]<<8^g[c&255],0===a%b&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:f[0][g[c>>>24]]^f[1][g[c>>16&255]]^f[2][g[c>>8&255]]^f[3][g[c&\n255]]};\nsjcl.cipher.aes.prototype={encrypt:function(a){return v(this,a,0)},decrypt:function(a){return v(this,a,1)},b:[[[],[],[],[],[]],[[],[],[],[],[]]],g:function(){var a=this.b[0],b=this.b[1],c=a[4],d=b[4],e,g,f,h=[],p=[],k,n,l,m;for(e=0;0x100>e;e++)p[(h[e]=e<<1^283*(e>>7))^e]=e;for(g=f=0;!c[g];g^=k||1,f=p[f]||1){l=f^f<<1^f<<2^f<<3^f<<4;l=l>>8^l&255^99;c[g]=l;d[l]=g;n=h[e=h[k=h[g]]];m=0x1010101*n^0x10001*e^0x101*k^0x1010100*g;n=0x101*h[l]^0x1010100*l;for(e=0;4>e;e++)a[e][g]=n=n<<24^n>>>8,b[e][l]=m=m<<24^m>>>8}for(e=\n0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};\nfunction v(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(\"invalid aes block size\");var d=a.e[c],e=b[0]^d[0],g=b[c?3:1]^d[1],f=b[2]^d[2];b=b[c?1:3]^d[3];var h,p,k,n=d.length/4-2,l,m=4,s=[0,0,0,0];h=a.b[c];a=h[0];var q=h[1],r=h[2],t=h[3],u=h[4];for(l=0;l<n;l++)h=a[e>>>24]^q[g>>16&255]^r[f>>8&255]^t[b&255]^d[m],p=a[g>>>24]^q[f>>16&255]^r[b>>8&255]^t[e&255]^d[m+1],k=a[f>>>24]^q[b>>16&255]^r[e>>8&255]^t[g&255]^d[m+2],b=a[b>>>24]^q[e>>16&255]^r[g>>8&255]^t[f&255]^d[m+3],m+=4,e=h,g=p,f=k;for(l=\n0;4>l;l++)s[c?3&-l:l]=u[e>>>24]<<24^u[g>>16&255]<<16^u[f>>8&255]<<8^u[b&255]^d[m++],h=e,e=g,g=f,f=b,b=h;return s}\nsjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.l(a.slice(b/32),32-(b&31)).slice(1);return void 0===c?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.l(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===\nb?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b&=31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===\nc},l:function(a,b,c,d){var e;e=0;for(void 0===d&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},n:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]}};\nsjcl.codec.utf8String={fromBits:function(a){var b=\"\",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>24),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};\nsjcl.codec.hex={fromBits:function(a){var b=\"\",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\\s|0x/g,\"\");d=a.length;a+=\"00000000\";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};\nsjcl.codec.base64={i:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",fromBits:function(a,b,c){var d=\"\",e=0,g=sjcl.codec.base64.i,f=0,h=sjcl.bitArray.bitLength(a);c&&(g=g.substr(0,62)+\"-_\");for(c=0;6*d.length<h;)d+=g.charAt((f^a[c]>>>e)>>>26),6>e?(f=a[c]<<6-e,e+=26,c++):(f<<=6,e-=6);for(;d.length&3&&!b;)d+=\"=\";return d},toBits:function(a,b){a=a.replace(/\\s|=/g,\"\");var c=[],d,e=0,g=sjcl.codec.base64.i,f=0,h;b&&(g=g.substr(0,62)+\"-_\");for(d=0;d<a.length;d++){h=g.indexOf(a.charAt(d));\nif(0>h)throw new sjcl.exception.invalid(\"this isn't base64!\");26<e?(e-=26,c.push(f^h>>>e),f=h<<32-e):(e+=6,f^=h<<32-e)}e&56&&c.push(sjcl.bitArray.partial(e&56,f,1));return c}};sjcl.codec.base64url={fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash.sha256=function(a){this.e[0]||this.g();a?(this.f=a.f.slice(0),this.d=a.d.slice(0),this.a=a.a):this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};\nsjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.f=this.k.slice(0);this.d=[];this.a=0;return this},update:function(a){\"string\"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.d=sjcl.bitArray.concat(this.d,a);b=this.a;a=this.a=b+sjcl.bitArray.bitLength(a);for(b=512+b&-512;b<=a;b+=512)w(this,c.splice(0,16));return this},finalize:function(){var a,b=this.d,c=this.f,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.a/\n4294967296));for(b.push(this.a|0);b.length;)w(this,b.splice(0,16));this.reset();return c},k:[],e:[],g:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}var b=0,c=2,d;a:for(;64>b;c++){for(d=2;d*d<=c;d++)if(0===c%d)continue a;8>b&&(this.k[b]=a(Math.pow(c,0.5)));this.e[b]=a(Math.pow(c,1/3));b++}}};\nfunction w(a,b){var c,d,e,g=b.slice(0),f=a.f,h=a.e,p=f[0],k=f[1],n=f[2],l=f[3],m=f[4],s=f[5],q=f[6],r=f[7];for(c=0;64>c;c++)16>c?d=g[c]:(d=g[c+1&15],e=g[c+14&15],d=g[c&15]=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+g[c&15]+g[c+9&15]|0),d=d+r+(m>>>6^m>>>11^m>>>25^m<<26^m<<21^m<<7)+(q^m&(s^q))+h[c],r=q,q=s,s=m,m=l+d|0,l=n,n=k,k=p,p=d+(k&n^l&(k^n))+(k>>>2^k>>>13^k>>>22^k<<30^k<<19^k<<10)|0;f[0]=f[0]+p|0;f[1]=f[1]+k|0;f[2]=f[2]+n|0;f[3]=f[3]+l|0;f[4]=f[4]+m|0;f[5]=f[5]+s|0;f[6]=\nf[6]+q|0;f[7]=f[7]+r|0}sjcl.misc.hmac=function(a,b){this.j=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.c=[new b,new b];a.length>e&&(a=b.hash(a));for(d=0;d<e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.c[0].update(c[0]);this.c[1].update(c[1]);this.h=new b(this.c[0])};sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.m)throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");this.update(a);return this.digest(a)};\nsjcl.misc.hmac.prototype.reset=function(){this.h=new this.j(this.c[0]);this.m=!1};sjcl.misc.hmac.prototype.update=function(a){this.m=!0;this.h.update(a)};sjcl.misc.hmac.prototype.digest=function(){var a=this.h.finalize(),a=(new this.j(this.c[1])).update(a).finalize();this.reset();return a};\nsjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E3;if(0>d||0>c)throw sjcl.exception.invalid(\"invalid params to pbkdf2\");\"string\"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));\"string\"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var g,f,h,p,k=[],n=sjcl.bitArray;for(p=1;32*k.length<(d||1);p++){e=g=a.encrypt(n.concat(b,[p]));for(f=1;f<c;f++){g=a.encrypt(g);for(h=0;h<g.length;h++)e[h]^=g[h]}k=k.concat(e)}d&&(k=n.clamp(k,d));return k};\n  return sjcl; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (hawk, ERRORS) {\n  'use strict';\n  /* global XMLHttpRequest */\n\n  /**\n   * @class Request\n   * @constructor\n   * @param {String} baseUri Base URI\n   * @param {Object} xhr XMLHttpRequest constructor\n   * @param {Object} [options={}] Options\n   *   @param {Number} [options.localtimeOffsetMsec]\n   *   Local time offset with the remote auth server's clock\n   */\n  function Request (baseUri, xhr, options) {\n    if (!options) {\n      options = {};\n    }\n    this.baseUri = baseUri;\n    this._localtimeOffsetMsec = options.localtimeOffsetMsec;\n    this.xhr = xhr || XMLHttpRequest;\n    this.timeout = options.timeout || 30 * 1000;\n  }\n\n  /**\n   * @method send\n   * @param {String} path Request path\n   * @param {String} method HTTP Method\n   * @param {Object} credentials HAWK Headers\n   * @param {Object} jsonPayload JSON Payload\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.retrying]\n   *   Flag indicating if the request is a retry\n   *   @param {Array} [options.headers]\n   *   A set of extra headers to add to the request\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  Request.prototype.send = function request(path, method, credentials, jsonPayload, options) {\n    /*eslint complexity: [2, 8] */\n    var xhr = new this.xhr();\n    var uri = this.baseUri + path;\n    var payload = null;\n    var self = this;\n    options = options || {};\n\n    if (jsonPayload) {\n      payload = JSON.stringify(jsonPayload);\n    }\n\n    try {\n      xhr.open(method, uri);\n    } catch (e) {\n      return Promise.reject({ error: 'Unknown error', message: e.toString(), errno: 999 });\n    }\n\n    return new Promise(function (resolve, reject) {\n      xhr.timeout = self.timeout;\n\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var result = xhr.responseText;\n          try {\n            result = JSON.parse(xhr.responseText);\n          } catch (e) { }\n\n          if (result.errno) {\n            // Try to recover from a timeskew error and not already tried\n            if (result.errno === ERRORS.INVALID_TIMESTAMP && !options.retrying) {\n              var serverTime = result.serverTime;\n              self._localtimeOffsetMsec = (serverTime * 1000) - new Date().getTime();\n\n              // add to options that the request is retrying\n              options.retrying = true;\n\n              return self.send(path, method, credentials, jsonPayload, options)\n                .then(resolve, reject);\n\n            } else {\n              return reject(result);\n            }\n          }\n\n          if (typeof xhr.status === 'undefined' || xhr.status !== 200) {\n            if (result.length === 0) {\n              return reject({ error: 'Timeout error', errno: 999 });\n            } else {\n              return reject({ error: 'Unknown error', message: result, errno: 999, code: xhr.status });\n            }\n          }\n\n          resolve(result);\n        }\n      };\n\n      // calculate Hawk header if credentials are supplied\n      if (credentials) {\n        var hawkHeader = hawk.client.header(uri, method, {\n                            credentials: credentials,\n                            payload: payload,\n                            contentType: 'application/json',\n                            localtimeOffsetMsec: self._localtimeOffsetMsec || 0\n                          });\n        xhr.setRequestHeader('authorization', hawkHeader.field);\n      }\n\n      xhr.setRequestHeader('Content-Type', 'application/json');\n\n      if (options && options.headers) {\n        // set extra headers for this request\n        for (var header in options.headers) {\n          xhr.setRequestHeader(header, options.headers[header]);\n        }\n      }\n\n      xhr.send(payload);\n    });\n  };\n\n  return Request;\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  return {\n    INVALID_TIMESTAMP: 111,\n    INCORRECT_EMAIL_CASE: 120\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (sjcl) {\n  'use strict';\n\n  /**\n   * hkdf - The HMAC-based Key Derivation Function\n   * based on https://github.com/mozilla/node-hkdf\n   *\n   * @class hkdf\n   * @param {bitArray} ikm Initial keying material\n   * @param {bitArray} info Key derivation data\n   * @param {bitArray} salt Salt\n   * @param {integer} length Length of the derived key in bytes\n   * @return promise object- It will resolve with `output` data\n   */\n  function hkdf(ikm, info, salt, length) {\n\n    var mac = new sjcl.misc.hmac(salt, sjcl.hash.sha256);\n    mac.update(ikm);\n\n    // compute the PRK\n    var prk = mac.digest();\n\n    // hash length is 32 because only sjcl.hash.sha256 is used at this moment\n    var hashLength = 32;\n    var num_blocks = Math.ceil(length / hashLength);\n    var prev = sjcl.codec.hex.toBits('');\n    var output = '';\n\n    for (var i = 0; i < num_blocks; i++) {\n      var hmac = new sjcl.misc.hmac(prk, sjcl.hash.sha256);\n\n      var input = sjcl.bitArray.concat(\n        sjcl.bitArray.concat(prev, info),\n        sjcl.codec.utf8String.toBits((String.fromCharCode(i + 1)))\n      );\n\n      hmac.update(input);\n\n      prev = hmac.digest();\n      output += sjcl.codec.hex.fromBits(prev);\n    }\n\n    var truncated = sjcl.bitArray.clamp(sjcl.codec.hex.toBits(output), length * 8);\n\n    return Promise.resolve(truncated);\n  }\n\n  return hkdf;\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(5),\n  __webpack_require__(0),\n  __webpack_require__(8),\n  __webpack_require__(2),\n  __webpack_require__(11),\n  __webpack_require__(12),\n  __webpack_require__(1),\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function (ES6Promise, sjcl, credentials, ERRORS, hawkCredentials, metricsContext, Request) {\n  'use strict';\n\n  // polyfill ES6 promises on browsers that do not support them.\n  ES6Promise.polyfill();\n\n  var VERSION = 'v1';\n  var uriVersionRegExp = new RegExp('/' + VERSION + '$');\n  var HKDF_SIZE = 2 * 32;\n\n  function isUndefined(val) {\n    return typeof val === 'undefined';\n  }\n\n  function isNull(val) {\n    return val === null;\n  }\n\n  function isEmptyObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]' && ! Object.keys(val).length;\n  }\n\n  function isEmptyString(val) {\n    return val === '';\n  }\n\n  function required(val, name) {\n    if (isUndefined(val) ||\n        isNull(val) ||\n        isEmptyObject(val) ||\n        isEmptyString(val)) {\n      throw new Error('Missing ' + name);\n    }\n  }\n\n  /**\n   * @class FxAccountClient\n   * @constructor\n   * @param {String} uri Auth Server URI\n   * @param {Object} config Configuration\n   */\n  function FxAccountClient(uri, config) {\n    if (! uri && ! config) {\n      throw new Error('Firefox Accounts auth server endpoint or configuration object required.');\n    }\n\n    if (typeof uri !== 'string') {\n      config = uri || {};\n      uri = config.uri;\n    }\n\n    if (typeof config === 'undefined') {\n      config = {};\n    }\n\n    if (! uri) {\n      throw new Error('FxA auth server uri not set.');\n    }\n\n    if (!uriVersionRegExp.test(uri)) {\n      uri = uri + '/' + VERSION;\n    }\n\n    this.request = new Request(uri, config.xhr, { localtimeOffsetMsec: config.localtimeOffsetMsec });\n  }\n\n  FxAccountClient.VERSION = VERSION;\n\n  /**\n   * @method signUp\n   * @param {String} email Email input\n   * @param {String} password Password input\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get the keyFetchToken\n   *   @param {String} [options.service]\n   *   Opaque alphanumeric token to be included in verification links\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.preVerified]\n   *   set email to be verified if possible\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.lang]\n   *   set the language for the 'Accept-Language' header\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.signUp = function (email, password, options) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(password, 'password');\n\n        return credentials.setup(email, password);\n      })\n      .then(\n        function (result) {\n          /*eslint complexity: [2, 13] */\n          var endpoint = '/account/create';\n          var data = {\n            email: result.emailUTF8,\n            authPW: sjcl.codec.hex.fromBits(result.authPW)\n          };\n          var requestOpts = {};\n\n          if (options) {\n            if (options.service) {\n              data.service = options.service;\n            }\n\n            if (options.redirectTo) {\n              data.redirectTo = options.redirectTo;\n            }\n\n            // preVerified is used for unit/functional testing\n            if (options.preVerified) {\n              data.preVerified = options.preVerified;\n            }\n\n            if (options.resume) {\n              data.resume = options.resume;\n            }\n\n            if (options.keys) {\n              endpoint += '?keys=true';\n            }\n\n            if (options.lang) {\n              requestOpts.headers = {\n                'Accept-Language': options.lang\n              };\n            }\n\n            if (options.metricsContext) {\n              data.metricsContext = metricsContext.marshall(options.metricsContext);\n            }\n          }\n\n          return self.request.send(endpoint, 'POST', null, data, requestOpts)\n            .then(\n              function(accountData) {\n                if (options && options.keys) {\n                  accountData.unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);\n                }\n                return accountData;\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * @method signIn\n   * @param {String} email Email input\n   * @param {String} password Password input\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get the keyFetchToken\n   *   @param {Boolean} [options.skipCaseError]\n   *   If `true`, the request will skip the incorrect case error\n   *   @param {String} [options.service]\n   *   Service being signed into\n   *   @param {String} [options.reason]\n   *   Reason for sign in. Can be one of: `signin`, `password_check`,\n   *   `password_change`, `password_reset`\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.originalLoginEmail]\n   *   If retrying after an \"incorrect email case\" error, this specifies\n   *   the email address as originally entered by the user.\n   *   @param {String} [options.verificationMethod]\n   *   Request a specific verification method be used for verifying the session,\n   *   e.g. 'email-2fa' or 'totp-2fa'.\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   *   @param {String} [options.unblockCode]\n   *   Login unblock code.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.signIn = function (email, password, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(password, 'password');\n\n        return credentials.setup(email, password);\n      })\n      .then(\n        function (result) {\n          var endpoint = '/account/login';\n\n          if (options.keys) {\n            endpoint += '?keys=true';\n          }\n\n          var data = {\n            email: result.emailUTF8,\n            authPW: sjcl.codec.hex.fromBits(result.authPW)\n          };\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n\n          if (options.reason) {\n            data.reason = options.reason;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.unblockCode) {\n            data.unblockCode = options.unblockCode;\n          }\n\n          if (options.originalLoginEmail) {\n            data.originalLoginEmail = options.originalLoginEmail;\n          }\n\n          if (options.verificationMethod) {\n            data.verificationMethod = options.verificationMethod;\n          }\n\n          return self.request.send(endpoint, 'POST', null, data)\n            .then(\n              function(accountData) {\n                if (options.keys) {\n                  accountData.unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);\n                }\n                return accountData;\n              },\n              function(error) {\n                if (error && error.email && error.errno === ERRORS.INCORRECT_EMAIL_CASE && !options.skipCaseError) {\n                  options.skipCaseError = true;\n                  options.originalLoginEmail = email;\n\n                  return self.signIn(error.email, password, options);\n                } else {\n                  throw error;\n                }\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * @method verifyCode\n   * @param {String} uid Account ID\n   * @param {String} code Verification code\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.service]\n   *   Service being signed into\n   *   @param {String} [options.reminder]\n   *   Reminder that was used to verify the account\n   *   @param {String} [options.type]\n   *   Type of code being verified, only supports `secondary` otherwise will verify account/sign-in\n   *   @param {Boolean} [options.marketingOptIn]\n   *   If `true`, notifies marketing of opt-in intent.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.verifyCode = function(uid, code, options) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(uid, 'uid');\n        required(code, 'verify code');\n\n        var data = {\n          uid: uid,\n          code: code\n        };\n\n        if (options) {\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.reminder) {\n            data.reminder = options.reminder;\n          }\n\n          if (options.type) {\n            data.type = options.type;\n          }\n\n          if (options.marketingOptIn) {\n            data.marketingOptIn = true;\n          }\n        }\n\n        return self.request.send('/recovery_email/verify_code', 'POST', null, data);\n      });\n  };\n\n  FxAccountClient.prototype.verifyTokenCode = function(sessionToken, uid, code) {\n    var self = this;\n\n    required(uid, 'uid');\n    required(code, 'verify token code');\n    required(sessionToken, 'sessionToken');\n\n    return Promise.resolve()\n      .then(function () {\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var data = {\n          uid: uid,\n          code: code\n        };\n\n        return self.request.send('/session/verify/token', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * @method recoveryEmailStatus\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.recoveryEmailStatus = function(sessionToken) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/recovery_email/status', 'GET', creds);\n      });\n  };\n\n  /**\n   * Re-sends a verification code to the account's recovery email address.\n   *\n   * @method recoveryEmailResendCode\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.email]\n   *   Code will be resent to this email, only used for secondary email codes\n   *   @param {String} [options.service]\n   *   Opaque alphanumeric token to be included in verification links\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.type]\n   *   Specifies the type of code to send, currently only supported type is\n   *   `upgradeSession`.\n   *   @param {String} [options.lang]\n   *   set the language for the 'Accept-Language' header\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.recoveryEmailResendCode = function(sessionToken, options) {\n    var self = this;\n    var data = {};\n    var requestOpts = {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        if (options) {\n          if (options.email) {\n            data.email = options.email;\n          }\n\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.type) {\n            data.type = options.type;\n          }\n\n          if (options.lang) {\n            requestOpts.headers = {\n              'Accept-Language': options.lang\n            };\n          }\n        }\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/recovery_email/resend_code', 'POST', creds, data, requestOpts);\n      });\n  };\n\n  /**\n   * Used to ask the server to send a recovery code.\n   * The API returns passwordForgotToken to the client.\n   *\n   * @method passwordForgotSendCode\n   * @param {String} email\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.service]\n   *   Opaque alphanumeric token to be included in verification links\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.lang]\n   *   set the language for the 'Accept-Language' header\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordForgotSendCode = function(email, options) {\n    var self = this;\n    var data = {\n      email: email\n    };\n    var requestOpts = {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n\n        if (options) {\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.lang) {\n            requestOpts.headers = {\n              'Accept-Language': options.lang\n            };\n          }\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n        }\n\n        return self.request.send('/password/forgot/send_code', 'POST', null, data, requestOpts);\n      });\n  };\n\n  /**\n   * Re-sends a verification code to the account's recovery email address.\n   * HAWK-authenticated with the passwordForgotToken.\n   *\n   * @method passwordForgotResendCode\n   * @param {String} email\n   * @param {String} passwordForgotToken\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.service]\n   *   Opaque alphanumeric token to be included in verification links\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.lang]\n   *   set the language for the 'Accept-Language' header\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordForgotResendCode = function(email, passwordForgotToken, options) {\n    var self = this;\n    var data = {\n      email: email\n    };\n    var requestOpts = {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(passwordForgotToken, 'passwordForgotToken');\n\n        if (options) {\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.lang) {\n            requestOpts.headers = {\n              'Accept-Language': options.lang\n            };\n          }\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n        }\n\n        return hawkCredentials(passwordForgotToken, 'passwordForgotToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/password/forgot/resend_code', 'POST', creds, data, requestOpts);\n      });\n  };\n\n  /**\n   * Submits the verification token to the server.\n   * The API returns accountResetToken to the client.\n   * HAWK-authenticated with the passwordForgotToken.\n   *\n   * @method passwordForgotVerifyCode\n   * @param {String} code\n   * @param {String} passwordForgotToken\n   * @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordForgotVerifyCode = function(code, passwordForgotToken, options) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(code, 'reset code');\n        required(passwordForgotToken, 'passwordForgotToken');\n\n        return hawkCredentials(passwordForgotToken, 'passwordForgotToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          code: code\n        };\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return self.request.send('/password/forgot/verify_code', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Returns the status for the passwordForgotToken.\n   * If the request returns a success response, the token has not yet been consumed.\n\n   * @method passwordForgotStatus\n   * @param {String} passwordForgotToken\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordForgotStatus = function(passwordForgotToken) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(passwordForgotToken, 'passwordForgotToken');\n\n        return hawkCredentials(passwordForgotToken, 'passwordForgotToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/password/forgot/status', 'GET', creds);\n      });\n  };\n\n  /**\n   * The API returns reset result to the client.\n   * HAWK-authenticated with accountResetToken\n   *\n   * @method accountReset\n   * @param {String} email\n   * @param {String} newPassword\n   * @param {String} accountResetToken\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, a new `keyFetchToken` is provisioned. `options.sessionToken`\n   *   is required if `options.keys` is true.\n   *   @param {Boolean} [options.sessionToken]\n   *   If `true`, a new `sessionToken` is provisioned.\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.accountReset = function(email, newPassword, accountResetToken, options) {\n    var self = this;\n    var data = {};\n    var unwrapBKey;\n\n    options = options || {};\n\n    if (options.sessionToken) {\n      data.sessionToken = options.sessionToken;\n    }\n\n    if (options.metricsContext) {\n      data.metricsContext = metricsContext.marshall(options.metricsContext);\n    }\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(newPassword, 'new password');\n        required(accountResetToken, 'accountResetToken');\n\n        if (options.keys) {\n          required(options.sessionToken, 'sessionToken');\n        }\n\n        return credentials.setup(email, newPassword);\n      })\n      .then(\n        function (result) {\n          if (options.keys) {\n            unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);\n          }\n\n          data.authPW = sjcl.codec.hex.fromBits(result.authPW);\n\n          return hawkCredentials(accountResetToken, 'accountResetToken',  HKDF_SIZE);\n        }\n      ).then(\n        function (creds) {\n          var queryParams = '';\n          if (options.keys) {\n            queryParams = '?keys=true';\n          }\n\n          var endpoint = '/account/reset' + queryParams;\n          return self.request.send(endpoint, 'POST', creds, data)\n            .then(\n              function(accountData) {\n                if (options.keys && accountData.keyFetchToken) {\n                  accountData.unwrapBKey = unwrapBKey;\n                }\n\n                return accountData;\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * Get the base16 bundle of encrypted kA|wrapKb.\n   *\n   * @method accountKeys\n   * @param {String} keyFetchToken\n   * @param {String} oldUnwrapBKey\n   * @return {Promise} A promise that will be fulfilled with JSON of {kA, kB}  of the key bundle\n   */\n  FxAccountClient.prototype.accountKeys = function(keyFetchToken, oldUnwrapBKey) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(keyFetchToken, 'keyFetchToken');\n        required(oldUnwrapBKey, 'oldUnwrapBKey');\n\n        return hawkCredentials(keyFetchToken, 'keyFetchToken',  3 * 32);\n      })\n      .then(function(creds) {\n        var bundleKey = sjcl.codec.hex.fromBits(creds.bundleKey);\n\n        return self.request.send('/account/keys', 'GET', creds)\n          .then(\n            function(payload) {\n\n              return credentials.unbundleKeyFetchResponse(bundleKey, payload.bundle);\n            });\n      })\n      .then(function(keys) {\n        return {\n          kB: sjcl.codec.hex.fromBits(\n            credentials.xor(\n              sjcl.codec.hex.toBits(keys.wrapKB),\n              sjcl.codec.hex.toBits(oldUnwrapBKey)\n            )\n          ),\n          kA: keys.kA\n        };\n      });\n  };\n\n  /**\n   * This deletes the account completely. All stored data is erased.\n   *\n   * @method accountDestroy\n   * @param {String} email Email input\n   * @param {String} password Password input\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.skipCaseError]\n   *   If `true`, the request will skip the incorrect case error\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.accountDestroy = function(email, password, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(password, 'password');\n\n        return credentials.setup(email, password);\n      })\n      .then(\n        function (result) {\n          var data = {\n            email: result.emailUTF8,\n            authPW: sjcl.codec.hex.fromBits(result.authPW)\n          };\n\n          return self.request.send('/account/destroy', 'POST', null, data)\n            .then(\n              function(response) {\n                return response;\n              },\n              function(error) {\n                // if incorrect email case error\n                if (error && error.email && error.errno === ERRORS.INCORRECT_EMAIL_CASE && !options.skipCaseError) {\n                  options.skipCaseError = true;\n\n                  return self.accountDestroy(error.email, password, options);\n                } else {\n                  throw error;\n                }\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * Gets the status of an account by uid.\n   *\n   * @method accountStatus\n   * @param {String} uid User account id\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.accountStatus = function(uid) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(uid, 'uid');\n\n        return self.request.send('/account/status?uid=' + uid, 'GET');\n      });\n  };\n\n  /**\n   * Gets the status of an account by email.\n   *\n   * @method accountStatusByEmail\n   * @param {String} email User account email\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.accountStatusByEmail = function(email) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n\n        return self.request.send('/account/status', 'POST', null, {email: email});\n      });\n  };\n\n  /**\n   * Destroys this session, by invalidating the sessionToken.\n   *\n   * @method sessionDestroy\n   * @param {String} sessionToken User session token\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.customSessionToken] Override which session token to destroy for this same user\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sessionDestroy = function(sessionToken, options) {\n    var self = this;\n    var data = {};\n    options = options || {};\n\n    if (options.customSessionToken) {\n      data.customSessionToken = options.customSessionToken;\n    }\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/session/destroy', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Responds successfully if the session status is valid, requires the sessionToken.\n   *\n   * @method sessionStatus\n   * @param {String} sessionToken User session token\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sessionStatus = function(sessionToken) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/session/status', 'GET', creds);\n      });\n  };\n\n  /**\n   * @method sessionReauth\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @param {String} email Email input\n   * @param {String} password Password input\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get the keyFetchToken\n   *   @param {Boolean} [options.skipCaseError]\n   *   If `true`, the request will skip the incorrect case error\n   *   @param {String} [options.service]\n   *   Service being accessed that needs reauthentication\n   *   @param {String} [options.reason]\n   *   Reason for reauthentication. Can be one of: `signin`, `password_check`,\n   *   `password_change`, `password_reset`\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.originalLoginEmail]\n   *   If retrying after an \"incorrect email case\" error, this specifies\n   *   the email address as originally entered by the user.\n   *   @param {String} [options.verificationMethod]\n   *   Request a specific verification method be used for verifying the session,\n   *   e.g. 'email-2fa' or 'totp-2fa'.\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   *   @param {String} [options.unblockCode]\n   *   Login unblock code.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sessionReauth = function (sessionToken, email, password, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(email, 'email');\n        required(password, 'password');\n\n        return credentials.setup(email, password);\n      })\n      .then(\n        function (result) {\n          var endpoint = '/session/reauth';\n\n          if (options.keys) {\n            endpoint += '?keys=true';\n          }\n\n          var data = {\n            email: result.emailUTF8,\n            authPW: sjcl.codec.hex.fromBits(result.authPW)\n          };\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n\n          if (options.reason) {\n            data.reason = options.reason;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.unblockCode) {\n            data.unblockCode = options.unblockCode;\n          }\n\n          if (options.originalLoginEmail) {\n            data.originalLoginEmail = options.originalLoginEmail;\n          }\n\n          if (options.verificationMethod) {\n            data.verificationMethod = options.verificationMethod;\n          }\n\n          return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE)\n            .then(function (creds) {\n              return self.request.send(endpoint, 'POST', creds, data);\n            })\n            .then(\n              function(accountData) {\n                if (options.keys) {\n                  accountData.unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);\n                }\n                return accountData;\n              },\n              function(error) {\n                if (error && error.email && error.errno === ERRORS.INCORRECT_EMAIL_CASE && !options.skipCaseError) {\n                  options.skipCaseError = true;\n                  options.originalLoginEmail = email;\n\n                  return self.sessionReauth(sessionToken, error.email, password, options);\n                } else {\n                  throw error;\n                }\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * Sign a BrowserID public key\n   *\n   * @method certificateSign\n   * @param {String} sessionToken User session token\n   * @param {Object} publicKey The key to sign\n   * @param {int} duration Time interval from now when the certificate will expire in milliseconds\n   * @param {Object} [options={}] Options\n   *   @param {String} [service=''] The requesting service, sent via the query string\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.certificateSign = function(sessionToken, publicKey, duration, options) {\n    var self = this;\n    var data = {\n      publicKey: publicKey,\n      duration: duration\n    };\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(publicKey, 'publicKey');\n        required(duration, 'duration');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        options = options || {};\n\n        var queryString = '';\n        if (options.service) {\n          queryString = '?service=' + encodeURIComponent(options.service);\n        }\n\n        return self.request.send('/certificate/sign' + queryString, 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Change the password from one known value to another.\n   *\n   * @method passwordChange\n   * @param {String} email\n   * @param {String} oldPassword\n   * @param {String} newPassword\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get a new keyFetchToken\n   *   @param {String} [options.sessionToken]\n   *   If a `sessionToken` is passed, a new sessionToken will be returned\n   *   with the same `verified` status as the existing sessionToken.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordChange = function(email, oldPassword, newPassword, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(oldPassword, 'old password');\n        required(newPassword, 'new password');\n\n        return self._passwordChangeStart(email, oldPassword);\n      })\n      .then(function (credentials) {\n\n        var oldCreds = credentials;\n        var emailToHashWith = credentials.emailToHashWith || email;\n\n        return self._passwordChangeKeys(oldCreds)\n          .then(function (keys) {\n\n            return self._passwordChangeFinish(emailToHashWith, newPassword, oldCreds, keys, options);\n          });\n      });\n\n  };\n\n  /**\n   * First step to change the password.\n   *\n   * @method passwordChangeStart\n   * @private\n   * @param {String} email\n   * @param {String} oldPassword\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.skipCaseError]\n   *   If `true`, the request will skip the incorrect case error\n   * @return {Promise} A promise that will be fulfilled with JSON of `xhr.responseText` and `oldUnwrapBKey`\n   */\n  FxAccountClient.prototype._passwordChangeStart = function(email, oldPassword, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(oldPassword, 'old password');\n\n        return credentials.setup(email, oldPassword);\n      })\n      .then(function (oldCreds) {\n        var data = {\n          email: oldCreds.emailUTF8,\n          oldAuthPW: sjcl.codec.hex.fromBits(oldCreds.authPW)\n        };\n\n        return self.request.send('/password/change/start', 'POST', null, data)\n          .then(\n            function(passwordData) {\n              passwordData.oldUnwrapBKey = sjcl.codec.hex.fromBits(oldCreds.unwrapBKey);\n\n              // Similar to password reset, this keeps the contract that we always\n              // hash passwords with the original account email.\n              passwordData.emailToHashWith = email;\n              return passwordData;\n            },\n            function(error) {\n              // if incorrect email case error\n              if (error && error.email && error.errno === ERRORS.INCORRECT_EMAIL_CASE && !options.skipCaseError) {\n                options.skipCaseError = true;\n\n                return self._passwordChangeStart(error.email, oldPassword, options);\n              } else {\n                throw error;\n              }\n            }\n          );\n      });\n  };\n\n  function checkCreds(creds) {\n    required(creds, 'credentials');\n    required(creds.oldUnwrapBKey, 'credentials.oldUnwrapBKey');\n    required(creds.keyFetchToken, 'credentials.keyFetchToken');\n    required(creds.passwordChangeToken, 'credentials.passwordChangeToken');\n  }\n\n  /**\n   * Second step to change the password.\n   *\n   * @method _passwordChangeKeys\n   * @private\n   * @param {Object} oldCreds This object should consists of `oldUnwrapBKey`, `keyFetchToken` and `passwordChangeToken`.\n   * @return {Promise} A promise that will be fulfilled with JSON of `xhr.responseText`\n   */\n  FxAccountClient.prototype._passwordChangeKeys = function(oldCreds) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        checkCreds(oldCreds);\n      })\n      .then(function () {\n        return self.accountKeys(oldCreds.keyFetchToken, oldCreds.oldUnwrapBKey);\n      });\n  };\n\n  /**\n   * Third step to change the password.\n   *\n   * @method _passwordChangeFinish\n   * @private\n   * @param {String} email\n   * @param {String} newPassword\n   * @param {Object} oldCreds This object should consists of `oldUnwrapBKey`, `keyFetchToken` and `passwordChangeToken`.\n   * @param {Object} keys This object should contain the unbundled keys\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get the keyFetchToken\n   *   @param {String} [options.sessionToken]\n   *   If a `sessionToken` is passed, a new sessionToken will be returned\n   *   with the same `verified` status as the existing sessionToken.\n   * @return {Promise} A promise that will be fulfilled with JSON of `xhr.responseText`\n   */\n  FxAccountClient.prototype._passwordChangeFinish = function(email, newPassword, oldCreds, keys, options) {\n    options = options || {};\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(newPassword, 'new password');\n        checkCreds(oldCreds);\n        required(keys, 'keys');\n        required(keys.kB, 'keys.kB');\n\n        var defers = [];\n        defers.push(credentials.setup(email, newPassword));\n        defers.push(hawkCredentials(oldCreds.passwordChangeToken, 'passwordChangeToken',  HKDF_SIZE));\n\n        if (options.sessionToken) {\n          // Unbundle session data to get session id\n          defers.push(hawkCredentials(options.sessionToken, 'sessionToken',  HKDF_SIZE));\n        }\n\n        return Promise.all(defers);\n      })\n      .then(function (results) {\n        var newCreds = results[0];\n        var hawkCreds = results[1];\n        var sessionData = results[2];\n        var newWrapKb = sjcl.codec.hex.fromBits(\n          credentials.xor(\n            sjcl.codec.hex.toBits(keys.kB),\n            newCreds.unwrapBKey\n          )\n        );\n\n        var queryParams = '';\n        if (options.keys) {\n          queryParams = '?keys=true';\n        }\n\n        var sessionTokenId;\n        if (sessionData && sessionData.id) {\n          sessionTokenId = sessionData.id;\n        }\n\n        return self.request.send('/password/change/finish' + queryParams, 'POST', hawkCreds, {\n          wrapKb: newWrapKb,\n          authPW: sjcl.codec.hex.fromBits(newCreds.authPW),\n          sessionToken: sessionTokenId\n        })\n        .then(function (accountData) {\n          if (options.keys && accountData.keyFetchToken) {\n            accountData.unwrapBKey = sjcl.codec.hex.fromBits(newCreds.unwrapBKey);\n          }\n          return accountData;\n        });\n      });\n  };\n\n  /**\n   * Get 32 bytes of random data. This should be combined with locally-sourced entropy when creating salts, etc.\n   *\n   * @method getRandomBytes\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.getRandomBytes = function() {\n\n    return this.request.send('/get_random_bytes', 'POST');\n  };\n\n  /**\n   * Add a new device\n   *\n   * @method deviceRegister\n   * @param {String} sessionToken User session token\n   * @param {String} deviceName Name of device\n   * @param {String} deviceType Type of device (mobile|desktop)\n   * @param {Object} [options={}] Options\n   *   @param {string} [options.deviceCallback] Device's push endpoint.\n   *   @param {string} [options.devicePublicKey] Public key used to encrypt push messages.\n   *   @param {string} [options.deviceAuthKey] Authentication secret used to encrypt push messages.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.deviceRegister = function (sessionToken, deviceName, deviceType, options) {\n    var request = this.request;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(deviceName, 'deviceName');\n        required(deviceType, 'deviceType');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          name: deviceName,\n          type: deviceType\n        };\n\n        if (options.deviceCallback) {\n          data.pushCallback = options.deviceCallback;\n        }\n\n        if (options.devicePublicKey && options.deviceAuthKey) {\n          data.pushPublicKey = options.devicePublicKey;\n          data.pushAuthKey = options.deviceAuthKey;\n        }\n\n        return request.send('/account/device', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Update the name of an existing device\n   *\n   * @method deviceUpdate\n   * @param {String} sessionToken User session token\n   * @param {String} deviceId User-unique identifier of device\n   * @param {String} deviceName Name of device\n   * @param {Object} [options={}] Options\n   *   @param {string} [options.deviceCallback] Device's push endpoint.\n   *   @param {string} [options.devicePublicKey] Public key used to encrypt push messages.\n   *   @param {string} [options.deviceAuthKey] Authentication secret used to encrypt push messages.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.deviceUpdate = function (sessionToken, deviceId, deviceName, options) {\n    var request = this.request;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(deviceId, 'deviceId');\n        required(deviceName, 'deviceName');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          id: deviceId,\n          name: deviceName\n        };\n\n        if (options.deviceCallback) {\n          data.pushCallback = options.deviceCallback;\n        }\n\n        if (options.devicePublicKey && options.deviceAuthKey) {\n          data.pushPublicKey = options.devicePublicKey;\n          data.pushAuthKey = options.deviceAuthKey;\n        }\n\n        return request.send('/account/device', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Unregister an existing device\n   *\n   * @method deviceDestroy\n   * @param {String} sessionToken Session token obtained from signIn\n   * @param {String} deviceId User-unique identifier of device\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.deviceDestroy = function (sessionToken, deviceId) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(deviceId, 'deviceId');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          id: deviceId\n        };\n\n        return request.send('/account/device/destroy', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Get a list of all devices for a user\n   *\n   * @method deviceList\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.deviceList = function (sessionToken) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/account/devices', 'GET', creds);\n      });\n  };\n\n  /**\n   * Get a list of user's sessions\n   *\n   * @method sessions\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sessions = function (sessionToken) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/account/sessions', 'GET', creds);\n      });\n  };\n\n  /**\n   * Send an unblock code\n   *\n   * @method sendUnblockCode\n   * @param {String} email email where to send the login authorization code\n   * @param {Object} [options={}] Options\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sendUnblockCode = function (email, options) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n\n        var data = {\n          email: email\n        };\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return self.request.send('/account/login/send_unblock_code', 'POST', null, data);\n      });\n  };\n\n  /**\n   * Reject a login unblock code. Code will be deleted from the server\n   * and will not be able to be used again.\n   *\n   * @method rejectLoginAuthorizationCode\n   * @param {String} uid Account ID\n   * @param {String} unblockCode unblock code\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.rejectUnblockCode = function (uid, unblockCode) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(uid, 'uid');\n        required(unblockCode, 'unblockCode');\n\n        var data = {\n          uid: uid,\n          unblockCode: unblockCode\n        };\n\n        return self.request.send('/account/login/reject_unblock_code', 'POST', null, data);\n      });\n  };\n\n  /**\n   * Send an sms.\n   *\n   * @method sendSms\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} phoneNumber Phone number sms will be sent to\n   * @param {String} messageId Corresponding message id that will be sent\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.lang] Language that sms will be sent in\n   *   @param {Array} [options.features] Array of features to be enabled for the request\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   */\n  FxAccountClient.prototype.sendSms = function (sessionToken, phoneNumber, messageId, options) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(phoneNumber, 'phoneNumber');\n        required(messageId, 'messageId');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          phoneNumber: phoneNumber,\n          messageId: messageId\n        };\n        var requestOpts = {};\n\n        if (options) {\n          if (options.lang) {\n            requestOpts.headers = {\n              'Accept-Language': options.lang\n            };\n          }\n\n          if (options.features) {\n            data.features = options.features;\n          }\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n        }\n\n        return request.send('/sms', 'POST', creds, data, requestOpts);\n      });\n  };\n\n  /**\n   * Get SMS status for the current user.\n   *\n   * @method smsStatus\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.country] country Country to force for testing.\n   */\n  FxAccountClient.prototype.smsStatus = function (sessionToken, options) {\n    var request = this.request;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var url = '/sms/status';\n        if (options.country) {\n          url += '?country=' + encodeURIComponent(options.country);\n        }\n        return request.send(url, 'GET', creds);\n      });\n  };\n\n  /**\n   * Consume a signinCode.\n   *\n   * @method consumeSigninCode\n   * @param {String} code The signinCode entered by the user\n   * @param {String} flowId Identifier for the current event flow\n   * @param {Number} flowBeginTime Timestamp for the flow.begin event\n   * @param {String} [deviceId] Identifier for the current device\n   */\n  FxAccountClient.prototype.consumeSigninCode = function (code, flowId, flowBeginTime, deviceId) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(code, 'code');\n        required(flowId, 'flowId');\n        required(flowBeginTime, 'flowBeginTime');\n\n        return self.request.send('/signinCodes/consume', 'POST', null, {\n          code: code,\n          metricsContext: {\n            deviceId: deviceId,\n            flowId: flowId,\n            flowBeginTime: flowBeginTime\n          }\n        });\n      });\n  };\n\n  /**\n   * Get the recovery emails associated with the signed in account.\n   *\n   * @method recoveryEmails\n   * @param {String} sessionToken SessionToken obtained from signIn\n   */\n  FxAccountClient.prototype.recoveryEmails = function (sessionToken) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/recovery_emails', 'GET', creds);\n      });\n  };\n\n  /**\n   * Create a new recovery email for the signed in account.\n   *\n   * @method recoveryEmailCreate\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} email new email to be added\n   */\n  FxAccountClient.prototype.recoveryEmailCreate = function (sessionToken, email) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(sessionToken, 'email');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          email: email\n        };\n\n        return request.send('/recovery_email', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Remove the recovery email for the signed in account.\n   *\n   * @method recoveryEmailDestroy\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} email email to be removed\n   */\n  FxAccountClient.prototype.recoveryEmailDestroy = function (sessionToken, email) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(sessionToken, 'email');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          email: email\n        };\n\n        return request.send('/recovery_email/destroy', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Changes user's primary email address.\n   *\n   * @method recoveryEmailSetPrimaryEmail\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} email Email that will be the new primary email for user\n   */\n  FxAccountClient.prototype.recoveryEmailSetPrimaryEmail = function (sessionToken, email) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          email: email\n        };\n        return request.send('/recovery_email/set_primary', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Creates a new TOTP token for the user associated with this session.\n   *\n   * @method createTotpToken\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {Object} [options.metricsContext={}] Metrics context metadata\n   *   @param {String} options.metricsContext.deviceId identifier for the current device\n   *   @param {String} options.metricsContext.flowId identifier for the current event flow\n   *   @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *   @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *   @param {Number} options.metricsContext.utmContent content identifier\n   *   @param {Number} options.metricsContext.utmMedium acquisition medium\n   *   @param {Number} options.metricsContext.utmSource traffic source\n   *   @param {Number} options.metricsContext.utmTerm search terms\n   */\n  FxAccountClient.prototype.createTotpToken = function (sessionToken, options) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken', HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var data = {};\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return request.send('/totp/create', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Deletes this user's TOTP token.\n   *\n   * @method deleteTotpToken\n   * @param {String} sessionToken SessionToken obtained from signIn\n   */\n  FxAccountClient.prototype.deleteTotpToken = function (sessionToken) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/totp/destroy', 'POST', creds, {});\n      });\n  };\n\n  /**\n   * Check to see if the current user has a TOTP token associated with\n   * their account.\n   *\n   * @method checkTotpTokenExists\n   * @param {String} sessionToken SessionToken obtained from signIn\n   */\n  FxAccountClient.prototype.checkTotpTokenExists = function (sessionToken) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/totp/exists', 'GET', creds);\n      });\n  };\n\n  /**\n   * Verify tokens if using a valid TOTP code.\n   *\n   * @method verifyTotpCode\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} code TOTP code to verif\n   * @param {Object} [options.metricsContext={}] Metrics context metadata\n   *   @param {String} options.metricsContext.deviceId identifier for the current device\n   *   @param {String} options.metricsContext.flowId identifier for the current event flow\n   *   @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *   @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *   @param {Number} options.metricsContext.utmContent content identifier\n   *   @param {Number} options.metricsContext.utmMedium acquisition medium\n   *   @param {Number} options.metricsContext.utmSource traffic source\n   *   @param {Number} options.metricsContext.utmTerm search terms\n   */\n  FxAccountClient.prototype.verifyTotpCode = function (sessionToken, code, options) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(code, 'code');\n\n        return hawkCredentials(sessionToken, 'sessionToken', HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var data = {\n          code: code\n        };\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return request.send('/session/verify/totp', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Replace user's recovery codes.\n   *\n   * @method replaceRecoveryCodes\n   * @param {String} sessionToken SessionToken obtained from signIn\n   */\n  FxAccountClient.prototype.replaceRecoveryCodes = function (sessionToken) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken', HKDF_SIZE);\n      })\n      .then(function (creds) {\n\n        return request.send('/recoveryCodes', 'GET', creds);\n      });\n  };\n\n  /**\n   * Consume recovery code.\n   *\n   * @method consumeRecoveryCode\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} code recovery code\n   * @param {Object} [options.metricsContext={}] Metrics context metadata\n   *   @param {String} options.metricsContext.deviceId identifier for the current device\n   *   @param {String} options.metricsContext.flowId identifier for the current event flow\n   *   @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *   @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *   @param {Number} options.metricsContext.utmContent content identifier\n   *   @param {Number} options.metricsContext.utmMedium acquisition medium\n   *   @param {Number} options.metricsContext.utmSource traffic source\n   *   @param {Number} options.metricsContext.utmTerm search terms\n   */\n  FxAccountClient.prototype.consumeRecoveryCode = function (sessionToken, code, options) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(code, 'code');\n\n        return hawkCredentials(sessionToken, 'sessionToken', HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var data = {\n          code: code\n        };\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return request.send('/session/verify/recoveryCode', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Check for a required argument. Exposed for unit testing.\n   *\n   * @param {Value} val - value to check\n   * @param {String} name - name of value\n   * @throws {Error} if argument is falsey, or an empty object\n   */\n  FxAccountClient.prototype._required = required;\n\n  return FxAccountClient;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var require;/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   4.1.1\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nvar _isArray = undefined;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = undefined;\nvar customSchedulerFn = undefined;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var r = require;\n    var vertx = __webpack_require__(7);\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = undefined;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var _arguments = arguments;\n\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n  if (_state) {\n    (function () {\n      var callback = _arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    })();\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(16);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar GET_THEN_ERROR = new ErrorObject();\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    GET_THEN_ERROR.error = error;\n    return GET_THEN_ERROR;\n  }\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === GET_THEN_ERROR) {\n      reject(promise, GET_THEN_ERROR.error);\n      GET_THEN_ERROR.error = null;\n    } else if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = undefined,\n      callback = undefined,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction ErrorObject() {\n  this.error = null;\n}\n\nvar TRY_CATCH_ERROR = new ErrorObject();\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = undefined,\n      error = undefined,\n      succeeded = undefined,\n      failed = undefined;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value.error = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n      resolve(promise, value);\n    } else if (failed) {\n      reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      reject(promise, value);\n    }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction Enumerator$1(Constructor, input) {\n  this._instanceConstructor = Constructor;\n  this.promise = new Constructor(noop);\n\n  if (!this.promise[PROMISE_ID]) {\n    makePromise(this.promise);\n  }\n\n  if (isArray(input)) {\n    this.length = input.length;\n    this._remaining = input.length;\n\n    this._result = new Array(this.length);\n\n    if (this.length === 0) {\n      fulfill(this.promise, this._result);\n    } else {\n      this.length = this.length || 0;\n      this._enumerate(input);\n      if (this._remaining === 0) {\n        fulfill(this.promise, this._result);\n      }\n    }\n  } else {\n    reject(this.promise, validationError());\n  }\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nEnumerator$1.prototype._enumerate = function (input) {\n  for (var i = 0; this._state === PENDING && i < input.length; i++) {\n    this._eachEntry(input[i], i);\n  }\n};\n\nEnumerator$1.prototype._eachEntry = function (entry, i) {\n  var c = this._instanceConstructor;\n  var resolve$$1 = c.resolve;\n\n  if (resolve$$1 === resolve$1) {\n    var _then = getThen(entry);\n\n    if (_then === then && entry._state !== PENDING) {\n      this._settledAt(entry._state, i, entry._result);\n    } else if (typeof _then !== 'function') {\n      this._remaining--;\n      this._result[i] = entry;\n    } else if (c === Promise$2) {\n      var promise = new c(noop);\n      handleMaybeThenable(promise, entry, _then);\n      this._willSettleAt(promise, i);\n    } else {\n      this._willSettleAt(new c(function (resolve$$1) {\n        return resolve$$1(entry);\n      }), i);\n    }\n  } else {\n    this._willSettleAt(resolve$$1(entry), i);\n  }\n};\n\nEnumerator$1.prototype._settledAt = function (state, i, value) {\n  var promise = this.promise;\n\n  if (promise._state === PENDING) {\n    this._remaining--;\n\n    if (state === REJECTED) {\n      reject(promise, value);\n    } else {\n      this._result[i] = value;\n    }\n  }\n\n  if (this._remaining === 0) {\n    fulfill(promise, this._result);\n  }\n};\n\nEnumerator$1.prototype._willSettleAt = function (promise, i) {\n  var enumerator = this;\n\n  subscribe(promise, undefined, function (value) {\n    return enumerator._settledAt(FULFILLED, i, value);\n  }, function (reason) {\n    return enumerator._settledAt(REJECTED, i, reason);\n  });\n};\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all$1(entries) {\n  return new Enumerator$1(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race$1(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/\nfunction Promise$2(resolver) {\n  this[PROMISE_ID] = nextId();\n  this._result = this._state = undefined;\n  this._subscribers = [];\n\n  if (noop !== resolver) {\n    typeof resolver !== 'function' && needsResolver();\n    this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();\n  }\n}\n\nPromise$2.all = all$1;\nPromise$2.race = race$1;\nPromise$2.resolve = resolve$1;\nPromise$2.reject = reject$1;\nPromise$2._setScheduler = setScheduler;\nPromise$2._setAsap = setAsap;\nPromise$2._asap = asap;\n\nPromise$2.prototype = {\n  constructor: Promise$2,\n\n  /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */\n  then: then,\n\n  /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */\n  'catch': function _catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\n/*global self*/\nfunction polyfill$1() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('polyfill failed because global object is unavailable in this environment');\n        }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n        var promiseToString = null;\n        try {\n            promiseToString = Object.prototype.toString.call(P.resolve());\n        } catch (e) {\n            // silently ignored\n        }\n\n        if (promiseToString === '[object Promise]' && !P.cast) {\n            return;\n        }\n    }\n\n    local.Promise = Promise$2;\n}\n\n// Strange compat..\nPromise$2.polyfill = polyfill$1;\nPromise$2.Promise = Promise$2;\n\nreturn Promise$2;\n\n})));\n\n//# sourceMappingURL=es6-promise.map\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(0), __webpack_require__(3), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Request, sjcl, hkdf, pbkdf2) {\n  'use strict';\n\n  // Key wrapping and stretching configuration.\n  var NAMESPACE = 'identity.mozilla.com/picl/v1/';\n  var PBKDF2_ROUNDS = 1000;\n  var STRETCHED_PASS_LENGTH_BYTES = 32 * 8;\n\n  var HKDF_SALT = sjcl.codec.hex.toBits('00');\n  var HKDF_LENGTH = 32;\n\n  /**\n   * Key Wrapping with a name\n   *\n   * @method kw\n   * @static\n   * @param {String} name The name of the salt\n   * @return {bitArray} the salt combination with the namespace\n   */\n  function kw(name) {\n    return sjcl.codec.utf8String.toBits(NAMESPACE + name);\n  }\n\n  /**\n   * Key Wrapping with a name and an email\n   *\n   * @method kwe\n   * @static\n   * @param {String} name The name of the salt\n   * @param {String} email The email of the user.\n   * @return {bitArray} the salt combination with the namespace\n   */\n  function kwe(name, email) {\n    return sjcl.codec.utf8String.toBits(NAMESPACE + name + ':' + email);\n  }\n\n  /**\n   * @class credentials\n   * @constructor\n   */\n  return {\n    /**\n     * Setup credentials\n     *\n     * @method setup\n     * @param {String} emailInput\n     * @param {String} passwordInput\n     * @return {Promise} A promise that will be fulfilled with `result` of generated credentials\n     */\n    setup: function (emailInput, passwordInput) {\n      var result = {};\n      var email = kwe('quickStretch', emailInput);\n      var password = sjcl.codec.utf8String.toBits(passwordInput);\n\n      result.emailUTF8 = emailInput;\n      result.passwordUTF8 = passwordInput;\n\n      return pbkdf2.derive(password, email, PBKDF2_ROUNDS, STRETCHED_PASS_LENGTH_BYTES)\n        .then(\n        function (quickStretchedPW) {\n          result.quickStretchedPW = quickStretchedPW;\n\n          return hkdf(quickStretchedPW, kw('authPW'), HKDF_SALT, HKDF_LENGTH)\n            .then(\n            function (authPW) {\n              result.authPW = authPW;\n\n              return hkdf(quickStretchedPW, kw('unwrapBkey'), HKDF_SALT, HKDF_LENGTH);\n            }\n          );\n        }\n      )\n        .then(\n        function (unwrapBKey) {\n          result.unwrapBKey = unwrapBKey;\n          return result;\n        }\n      );\n    },\n    /**\n     * Wrap\n     *\n     * @method wrap\n     * @param {bitArray} bitArray1\n     * @param {bitArray} bitArray2\n     * @return {bitArray} wrap result of the two bitArrays\n     */\n    xor: function (bitArray1, bitArray2) {\n      var result = [];\n\n      for (var i = 0; i < bitArray1.length; i++) {\n        result[i] = bitArray1[i] ^ bitArray2[i];\n      }\n\n      return result;\n    },\n    /**\n     * Unbundle the WrapKB\n     * @param {String} key Bundle Key in hex\n     * @param {String} bundle Key bundle in hex\n     * @returns {*}\n     */\n    unbundleKeyFetchResponse: function (key, bundle) {\n      var self = this;\n      var bitBundle = sjcl.codec.hex.toBits(bundle);\n\n      return this.deriveBundleKeys(key, 'account/keys')\n        .then(\n          function (keys) {\n            var ciphertext = sjcl.bitArray.bitSlice(bitBundle, 0, 8 * 64);\n            var expectedHmac = sjcl.bitArray.bitSlice(bitBundle, 8 * -32);\n            var hmac = new sjcl.misc.hmac(keys.hmacKey, sjcl.hash.sha256);\n            hmac.update(ciphertext);\n\n            if (!sjcl.bitArray.equal(hmac.digest(), expectedHmac)) {\n              throw new Error('Bad HMac');\n            }\n\n            var keyAWrapB = self.xor(sjcl.bitArray.bitSlice(bitBundle, 0, 8 * 64), keys.xorKey);\n\n            return {\n              kA: sjcl.codec.hex.fromBits(sjcl.bitArray.bitSlice(keyAWrapB, 0, 8 * 32)),\n              wrapKB: sjcl.codec.hex.fromBits(sjcl.bitArray.bitSlice(keyAWrapB, 8 * 32))\n            };\n          }\n        );\n    },\n    /**\n     * Derive the HMAC and XOR keys required to encrypt a given size of payload.\n     * @param {String} key Hex Bundle Key\n     * @param {String} keyInfo Bundle Key Info\n     * @returns {Object} hmacKey, xorKey\n     */\n    deriveBundleKeys: function(key, keyInfo) {\n      var bitKeyInfo = kw(keyInfo);\n      var salt = sjcl.codec.hex.toBits('');\n      key = sjcl.codec.hex.toBits(key);\n\n      return hkdf(key, bitKeyInfo, salt, 3 * 32)\n        .then(\n          function (keyMaterial) {\n\n            return {\n              hmacKey: sjcl.bitArray.bitSlice(keyMaterial, 0, 8 * 32),\n              xorKey: sjcl.bitArray.bitSlice(keyMaterial, 8 * 32)\n            };\n          }\n        );\n    }\n  };\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (sjcl) {\n  'use strict';\n\n  /*\n   HTTP Hawk Authentication Scheme\n   Copyright (c) 2012-2013, Eran Hammer <eran@hueniverse.com>\n   MIT Licensed\n   */\n\n\n  // Declare namespace\n\n  var hawk = {};\n\n  hawk.client = {\n\n    // Generate an Authorization header for a given request\n\n    /*\n     uri: 'http://example.com/resource?a=b'\n     method: HTTP verb (e.g. 'GET', 'POST')\n     options: {\n\n     // Required\n\n     credentials: {\n     id: 'dh37fgj492je',\n     key: 'aoijedoaijsdlaksjdl',\n     algorithm: 'sha256'                                 // 'sha1', 'sha256'\n     },\n\n     // Optional\n\n     ext: 'application-specific',                        // Application specific data sent via the ext attribute\n     timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds\n     nonce: '2334f34f',                                  // A pre-generated nonce\n     localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)\n     payload: '{\"some\":\"payload\"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)\n     contentType: 'application/json',                    // Payload content-type (ignored if hash provided)\n     hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash\n     app: '24s23423f34dx',                               // Oz application id\n     dlg: '234sz34tww3sd'                                // Oz delegated-by application id\n     }\n     */\n\n    header: function (uri, method, options) {\n      /*eslint complexity: [2, 21] */\n      var result = {\n        field: '',\n        artifacts: {}\n      };\n\n      // Validate inputs\n\n      if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||\n        !method || typeof method !== 'string' ||\n        !options || typeof options !== 'object') {\n\n        result.err = 'Invalid argument type';\n        return result;\n      }\n\n      // Application time\n\n      var timestamp = options.timestamp || Math.floor((hawk.utils.now() + (options.localtimeOffsetMsec || 0)) / 1000);\n\n      // Validate credentials\n\n      var credentials = options.credentials;\n      if (!credentials ||\n        !credentials.id ||\n        !credentials.key ||\n        !credentials.algorithm) {\n\n        result.err = 'Invalid credential object';\n        return result;\n      }\n\n      if (hawk.utils.baseIndexOf(hawk.crypto.algorithms, credentials.algorithm) === -1) {\n        result.err = 'Unknown algorithm';\n        return result;\n      }\n\n      // Parse URI\n\n      if (typeof uri === 'string') {\n        uri = hawk.utils.parseUri(uri);\n      }\n\n      // Calculate signature\n\n      var artifacts = {\n        ts: timestamp,\n        nonce: options.nonce || hawk.utils.randomString(6),\n        method: method,\n        resource: uri.relative,\n        host: uri.hostname,\n        port: uri.port,\n        hash: options.hash,\n        ext: options.ext,\n        app: options.app,\n        dlg: options.dlg\n      };\n\n      result.artifacts = artifacts;\n\n      // Calculate payload hash\n\n      if (!artifacts.hash &&\n        options.hasOwnProperty('payload')) {\n\n        artifacts.hash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);\n      }\n\n      var mac = hawk.crypto.calculateMac('header', credentials, artifacts);\n\n      // Construct header\n\n      var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed\n      var header = 'Hawk id=\"' + credentials.id +\n        '\", ts=\"' + artifacts.ts +\n        '\", nonce=\"' + artifacts.nonce +\n        (artifacts.hash ? '\", hash=\"' + artifacts.hash : '') +\n        (hasExt ? '\", ext=\"' + hawk.utils.escapeHeaderAttribute(artifacts.ext) : '') +\n        '\", mac=\"' + mac + '\"';\n\n      if (artifacts.app) {\n        header += ', app=\"' + artifacts.app +\n          (artifacts.dlg ? '\", dlg=\"' + artifacts.dlg : '') + '\"';\n      }\n\n      result.field = header;\n\n      return result;\n    },\n\n\n    // Validate server response\n\n    /*\n     request:    object created via 'new XMLHttpRequest()' after response received\n     artifacts:  object recieved from header().artifacts\n     options: {\n     payload:    optional payload received\n     required:   specifies if a Server-Authorization header is required. Defaults to 'false'\n     }\n     */\n\n    authenticate: function (request, credentials, artifacts, options) {\n\n      options = options || {};\n\n      if (request.getResponseHeader('www-authenticate')) {\n\n        // Parse HTTP WWW-Authenticate header\n\n        var attrsAuth = hawk.utils.parseAuthorizationHeader(request.getResponseHeader('www-authenticate'), ['ts', 'tsm', 'error']);\n        if (!attrsAuth) {\n          return false;\n        }\n\n        if (attrsAuth.ts) {\n          var tsm = hawk.crypto.calculateTsMac(attrsAuth.ts, credentials);\n          if (tsm !== attrsAuth.tsm) {\n            return false;\n          }\n\n          hawk.utils.setNtpOffset(attrsAuth.ts - Math.floor((new Date()).getTime() / 1000));     // Keep offset at 1 second precision\n        }\n      }\n\n      // Parse HTTP Server-Authorization header\n\n      if (!request.getResponseHeader('server-authorization') &&\n        !options.required) {\n\n        return true;\n      }\n\n      var attributes = hawk.utils.parseAuthorizationHeader(request.getResponseHeader('server-authorization'), ['mac', 'ext', 'hash']);\n      if (!attributes) {\n        return false;\n      }\n\n      var modArtifacts = {\n        ts: artifacts.ts,\n        nonce: artifacts.nonce,\n        method: artifacts.method,\n        resource: artifacts.resource,\n        host: artifacts.host,\n        port: artifacts.port,\n        hash: attributes.hash,\n        ext: attributes.ext,\n        app: artifacts.app,\n        dlg: artifacts.dlg\n      };\n\n      var mac = hawk.crypto.calculateMac('response', credentials, modArtifacts);\n      if (mac !== attributes.mac) {\n        return false;\n      }\n\n      if (!options.hasOwnProperty('payload')) {\n        return true;\n      }\n\n      if (!attributes.hash) {\n        return false;\n      }\n\n      var calculatedHash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.getResponseHeader('content-type'));\n      return (calculatedHash === attributes.hash);\n    },\n\n    message: function (host, port, message, options) {\n\n      // Validate inputs\n\n      if (!host || typeof host !== 'string' ||\n        !port || typeof port !== 'number' ||\n        message === null || message === undefined || typeof message !== 'string' ||\n        !options || typeof options !== 'object') {\n\n        return null;\n      }\n\n      // Application time\n\n      var timestamp = options.timestamp || Math.floor((hawk.utils.now() + (options.localtimeOffsetMsec || 0)) / 1000);\n\n      // Validate credentials\n\n      var credentials = options.credentials;\n      if (!credentials ||\n        !credentials.id ||\n        !credentials.key ||\n        !credentials.algorithm) {\n\n        // Invalid credential object\n        return null;\n      }\n\n      if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {\n        return null;\n      }\n\n      // Calculate signature\n\n      var artifacts = {\n        ts: timestamp,\n        nonce: options.nonce || hawk.utils.randomString(6),\n        host: host,\n        port: port,\n        hash: hawk.crypto.calculatePayloadHash(message, credentials.algorithm)\n      };\n\n      // Construct authorization\n\n      var result = {\n        id: credentials.id,\n        ts: artifacts.ts,\n        nonce: artifacts.nonce,\n        hash: artifacts.hash,\n        mac: hawk.crypto.calculateMac('message', credentials, artifacts)\n      };\n\n      return result;\n    },\n\n    authenticateTimestamp: function (message, credentials, updateClock) {           // updateClock defaults to true\n\n      var tsm = hawk.crypto.calculateTsMac(message.ts, credentials);\n      if (tsm !== message.tsm) {\n        return false;\n      }\n\n      if (updateClock !== false) {\n        hawk.utils.setNtpOffset(message.ts - Math.floor((new Date()).getTime() / 1000));    // Keep offset at 1 second precision\n      }\n\n      return true;\n    }\n  };\n\n\n  hawk.crypto = {\n\n    headerVersion: '1',\n\n    algorithms: ['sha1', 'sha256'],\n\n    calculateMac: function (type, credentials, options) {\n      var normalized = hawk.crypto.generateNormalizedString(type, options);\n      var hmac = new sjcl.misc.hmac(credentials.key, sjcl.hash.sha256);\n      hmac.update(normalized);\n\n      return sjcl.codec.base64.fromBits(hmac.digest());\n    },\n\n    generateNormalizedString: function (type, options) {\n\n      var normalized = 'hawk.' + hawk.crypto.headerVersion + '.' + type + '\\n' +\n        options.ts + '\\n' +\n        options.nonce + '\\n' +\n        (options.method || '').toUpperCase() + '\\n' +\n        (options.resource || '') + '\\n' +\n        options.host.toLowerCase() + '\\n' +\n        options.port + '\\n' +\n        (options.hash || '') + '\\n';\n\n      if (options.ext) {\n        normalized += options.ext.replace('\\\\', '\\\\\\\\').replace('\\n', '\\\\n');\n      }\n\n      normalized += '\\n';\n\n      if (options.app) {\n        normalized += options.app + '\\n' +\n          (options.dlg || '') + '\\n';\n      }\n\n      return normalized;\n    },\n\n    calculatePayloadHash: function (payload, algorithm, contentType) {\n      var hash = new sjcl.hash.sha256();\n      hash.update('hawk.' + hawk.crypto.headerVersion + '.payload\\n')\n        .update(hawk.utils.parseContentType(contentType) + '\\n')\n        .update(payload || '')\n        .update('\\n');\n\n      return sjcl.codec.base64.fromBits(hash.finalize());\n    },\n\n    calculateTsMac: function (ts, credentials) {\n      var hmac = new sjcl.misc.hmac(credentials.key, sjcl.hash.sha256);\n      hmac.update('hawk.' + hawk.crypto.headerVersion + '.ts\\n' + ts + '\\n');\n\n      return sjcl.codec.base64.fromBits(hmac.digest());\n    }\n  };\n\n\n  hawk.utils = {\n\n    storage: {                                      // localStorage compatible interface\n      _cache: {},\n      setItem: function (key, value) {\n\n        hawk.utils.storage._cache[key] = value;\n      },\n      getItem: function (key) {\n\n        return hawk.utils.storage._cache[key];\n      }\n    },\n\n    setStorage: function (storage) {\n\n      var ntpOffset = hawk.utils.getNtpOffset() || 0;\n      hawk.utils.storage = storage;\n      hawk.utils.setNtpOffset(ntpOffset);\n    },\n\n    setNtpOffset: function (offset) {\n\n      try {\n        hawk.utils.storage.setItem('hawk_ntp_offset', offset);\n      }\n      catch (err) {\n        console.error('[hawk] could not write to storage.');\n        console.error(err);\n      }\n    },\n\n    getNtpOffset: function () {\n\n      return parseInt(hawk.utils.storage.getItem('hawk_ntp_offset') || '0', 10);\n    },\n\n    now: function () {\n\n      return (new Date()).getTime() + hawk.utils.getNtpOffset();\n    },\n\n    escapeHeaderAttribute: function (attribute) {\n\n      return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');\n    },\n\n    parseContentType: function (header) {\n\n      if (!header) {\n        return '';\n      }\n\n      return header.split(';')[0].replace(/^\\s+|\\s+$/g, '').toLowerCase();\n    },\n\n    parseAuthorizationHeader: function (header, keys) {\n\n      if (!header) {\n        return null;\n      }\n\n      var headerParts = header.match(/^(\\w+)(?:\\s+(.*))?$/);       // Header: scheme[ something]\n      if (!headerParts) {\n        return null;\n      }\n\n      var scheme = headerParts[1];\n      if (scheme.toLowerCase() !== 'hawk') {\n        return null;\n      }\n\n      var attributesString = headerParts[2];\n      if (!attributesString) {\n        return null;\n      }\n\n      var attributes = {};\n      var verify = attributesString.replace(/(\\w+)=\"([^\"\\\\]*)\"\\s*(?:,\\s*|$)/g, function ($0, $1, $2) {\n\n        // Check valid attribute names\n\n        if (keys.indexOf($1) === -1) {\n          return;\n        }\n\n        // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9\n\n        if ($2.match(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~]+$/) === null) {\n          return;\n        }\n\n        // Check for duplicates\n\n        if (attributes.hasOwnProperty($1)) {\n          return;\n        }\n\n        attributes[$1] = $2;\n        return '';\n      });\n\n      if (verify !== '') {\n        return null;\n      }\n\n      return attributes;\n    },\n\n    randomString: function (size) {\n\n      var randomSource = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n      var len = randomSource.length;\n\n      var result = [];\n      for (var i = 0; i < size; ++i) {\n        result[i] = randomSource[Math.floor(Math.random() * len)];\n      }\n\n      return result.join('');\n    },\n\n    baseIndexOf: function(array, value, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n      while (++index < length) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    },\n\n    parseUri: function (input) {\n\n      // Based on: parseURI 1.2.2\n      // http://blog.stevenlevithan.com/archives/parseuri\n      // (c) Steven Levithan <stevenlevithan.com>\n      // MIT License\n\n      var keys = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'hostname', 'port', 'resource', 'relative', 'pathname', 'directory', 'file', 'query', 'fragment'];\n\n      var uriRegex = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?(((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?)(?:#(.*))?)/;\n      var uriByNumber = uriRegex.exec(input);\n      var uri = {};\n\n      var i = 15;\n      while (i--) {\n        uri[keys[i]] = uriByNumber[i] || '';\n      }\n\n      if (uri.port === null ||\n        uri.port === '') {\n\n        uri.port = (uri.protocol.toLowerCase() === 'http' ? '80' : (uri.protocol.toLowerCase() === 'https' ? '443' : ''));\n      }\n\n      return uri;\n    }\n  };\n\n\n  return hawk;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (sjcl, P) {\n  'use strict';\n\n  /**\n   * @class pbkdf2\n   * @constructor\n   */\n  var pbkdf2 = {\n    /**\n     * @method derive\n     * @param  {bitArray} input The password hex buffer.\n     * @param  {bitArray} salt The salt string buffer.\n     * @return {int} iterations the derived key bit array.\n     */\n    derive: function(input, salt, iterations, len) {\n      var result = sjcl.misc.pbkdf2(input, salt, iterations, len, sjcl.misc.hmac);\n      return Promise.resolve(result);\n    }\n  };\n\n  return pbkdf2;\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (sjcl, hkdf) {\n  'use strict';\n\n  var PREFIX_NAME = 'identity.mozilla.com/picl/v1/';\n  var bitSlice = sjcl.bitArray.bitSlice;\n  var salt = sjcl.codec.hex.toBits('');\n\n  /**\n   * @class hawkCredentials\n   * @method deriveHawkCredentials\n   * @param {String} tokenHex\n   * @param {String} context\n   * @param {int} size\n   * @returns {Promise}\n   */\n  function deriveHawkCredentials(tokenHex, context, size) {\n    var token = sjcl.codec.hex.toBits(tokenHex);\n    var info = sjcl.codec.utf8String.toBits(PREFIX_NAME + context);\n\n    return hkdf(token, info, salt, size || 3 * 32)\n      .then(function(out) {\n        var authKey = bitSlice(out, 8 * 32, 8 * 64);\n        var bundleKey = bitSlice(out, 8 * 64);\n\n        return {\n          algorithm: 'sha256',\n          id: sjcl.codec.hex.fromBits(bitSlice(out, 0, 8 * 32)),\n          key: authKey,\n          bundleKey: bundleKey\n        };\n      });\n  }\n\n  return deriveHawkCredentials;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// This module does the handling for the metrics context\n// activity event metadata.\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  'use strict';\n\n  return {\n    marshall: function (data) {\n      return {\n        deviceId: data.deviceId,\n        flowId: data.flowId,\n        flowBeginTime: data.flowBeginTime,\n        utmCampaign: data.utmCampaign,\n        utmContent: data.utmContent,\n        utmMedium: data.utmMedium,\n        utmSource: data.utmSource,\n        utmTerm: data.utmTerm\n      };\n    }\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// fxa-client.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b56f7b7769039ed72f50","define([], function () {\"use strict\";var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return\"CORRUPT: \"+this.message};this.message=a},invalid:function(a){this.toString=function(){return\"INVALID: \"+this.message};this.message=a},bug:function(a){this.toString=function(){return\"BUG: \"+this.message};this.message=a},notReady:function(a){this.toString=function(){return\"NOT READY: \"+this.message};this.message=a}}};\n\"undefined\"!==typeof module&&module.exports&&(module.exports=sjcl);\nsjcl.cipher.aes=function(a){this.b[0][0][0]||this.g();var b,c,d,e,g=this.b[0][4],f=this.b[1];b=a.length;var h=1;if(4!==b&&6!==b&&8!==b)throw new sjcl.exception.invalid(\"invalid aes key size\");this.e=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=g[c>>>24]<<24^g[c>>16&255]<<16^g[c>>8&255]<<8^g[c&255],0===a%b&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:f[0][g[c>>>24]]^f[1][g[c>>16&255]]^f[2][g[c>>8&255]]^f[3][g[c&\n255]]};\nsjcl.cipher.aes.prototype={encrypt:function(a){return v(this,a,0)},decrypt:function(a){return v(this,a,1)},b:[[[],[],[],[],[]],[[],[],[],[],[]]],g:function(){var a=this.b[0],b=this.b[1],c=a[4],d=b[4],e,g,f,h=[],p=[],k,n,l,m;for(e=0;0x100>e;e++)p[(h[e]=e<<1^283*(e>>7))^e]=e;for(g=f=0;!c[g];g^=k||1,f=p[f]||1){l=f^f<<1^f<<2^f<<3^f<<4;l=l>>8^l&255^99;c[g]=l;d[l]=g;n=h[e=h[k=h[g]]];m=0x1010101*n^0x10001*e^0x101*k^0x1010100*g;n=0x101*h[l]^0x1010100*l;for(e=0;4>e;e++)a[e][g]=n=n<<24^n>>>8,b[e][l]=m=m<<24^m>>>8}for(e=\n0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};\nfunction v(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid(\"invalid aes block size\");var d=a.e[c],e=b[0]^d[0],g=b[c?3:1]^d[1],f=b[2]^d[2];b=b[c?1:3]^d[3];var h,p,k,n=d.length/4-2,l,m=4,s=[0,0,0,0];h=a.b[c];a=h[0];var q=h[1],r=h[2],t=h[3],u=h[4];for(l=0;l<n;l++)h=a[e>>>24]^q[g>>16&255]^r[f>>8&255]^t[b&255]^d[m],p=a[g>>>24]^q[f>>16&255]^r[b>>8&255]^t[e&255]^d[m+1],k=a[f>>>24]^q[b>>16&255]^r[e>>8&255]^t[g&255]^d[m+2],b=a[b>>>24]^q[e>>16&255]^r[g>>8&255]^t[f&255]^d[m+3],m+=4,e=h,g=p,f=k;for(l=\n0;4>l;l++)s[c?3&-l:l]=u[e>>>24]<<24^u[g>>16&255]<<16^u[f>>8&255]<<8^u[b&255]^d[m++],h=e,e=g,g=f,f=b,b=h;return s}\nsjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.l(a.slice(b/32),32-(b&31)).slice(1);return void 0===c?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.l(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===\nb?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b&=31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===\nc},l:function(a,b,c,d){var e;e=0;for(void 0===d&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},n:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]}};\nsjcl.codec.utf8String={fromBits:function(a){var b=\"\",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>24),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};\nsjcl.codec.hex={fromBits:function(a){var b=\"\",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\\s|0x/g,\"\");d=a.length;a+=\"00000000\";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};\nsjcl.codec.base64={i:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",fromBits:function(a,b,c){var d=\"\",e=0,g=sjcl.codec.base64.i,f=0,h=sjcl.bitArray.bitLength(a);c&&(g=g.substr(0,62)+\"-_\");for(c=0;6*d.length<h;)d+=g.charAt((f^a[c]>>>e)>>>26),6>e?(f=a[c]<<6-e,e+=26,c++):(f<<=6,e-=6);for(;d.length&3&&!b;)d+=\"=\";return d},toBits:function(a,b){a=a.replace(/\\s|=/g,\"\");var c=[],d,e=0,g=sjcl.codec.base64.i,f=0,h;b&&(g=g.substr(0,62)+\"-_\");for(d=0;d<a.length;d++){h=g.indexOf(a.charAt(d));\nif(0>h)throw new sjcl.exception.invalid(\"this isn't base64!\");26<e?(e-=26,c.push(f^h>>>e),f=h<<32-e):(e+=6,f^=h<<32-e)}e&56&&c.push(sjcl.bitArray.partial(e&56,f,1));return c}};sjcl.codec.base64url={fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash.sha256=function(a){this.e[0]||this.g();a?(this.f=a.f.slice(0),this.d=a.d.slice(0),this.a=a.a):this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};\nsjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.f=this.k.slice(0);this.d=[];this.a=0;return this},update:function(a){\"string\"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.d=sjcl.bitArray.concat(this.d,a);b=this.a;a=this.a=b+sjcl.bitArray.bitLength(a);for(b=512+b&-512;b<=a;b+=512)w(this,c.splice(0,16));return this},finalize:function(){var a,b=this.d,c=this.f,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.a/\n4294967296));for(b.push(this.a|0);b.length;)w(this,b.splice(0,16));this.reset();return c},k:[],e:[],g:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}var b=0,c=2,d;a:for(;64>b;c++){for(d=2;d*d<=c;d++)if(0===c%d)continue a;8>b&&(this.k[b]=a(Math.pow(c,0.5)));this.e[b]=a(Math.pow(c,1/3));b++}}};\nfunction w(a,b){var c,d,e,g=b.slice(0),f=a.f,h=a.e,p=f[0],k=f[1],n=f[2],l=f[3],m=f[4],s=f[5],q=f[6],r=f[7];for(c=0;64>c;c++)16>c?d=g[c]:(d=g[c+1&15],e=g[c+14&15],d=g[c&15]=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+g[c&15]+g[c+9&15]|0),d=d+r+(m>>>6^m>>>11^m>>>25^m<<26^m<<21^m<<7)+(q^m&(s^q))+h[c],r=q,q=s,s=m,m=l+d|0,l=n,n=k,k=p,p=d+(k&n^l&(k^n))+(k>>>2^k>>>13^k>>>22^k<<30^k<<19^k<<10)|0;f[0]=f[0]+p|0;f[1]=f[1]+k|0;f[2]=f[2]+n|0;f[3]=f[3]+l|0;f[4]=f[4]+m|0;f[5]=f[5]+s|0;f[6]=\nf[6]+q|0;f[7]=f[7]+r|0}sjcl.misc.hmac=function(a,b){this.j=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.c=[new b,new b];a.length>e&&(a=b.hash(a));for(d=0;d<e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.c[0].update(c[0]);this.c[1].update(c[1]);this.h=new b(this.c[0])};sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.m)throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");this.update(a);return this.digest(a)};\nsjcl.misc.hmac.prototype.reset=function(){this.h=new this.j(this.c[0]);this.m=!1};sjcl.misc.hmac.prototype.update=function(a){this.m=!0;this.h.update(a)};sjcl.misc.hmac.prototype.digest=function(){var a=this.h.finalize(),a=(new this.j(this.c[1])).update(a).finalize();this.reset();return a};\nsjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1E3;if(0>d||0>c)throw sjcl.exception.invalid(\"invalid params to pbkdf2\");\"string\"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));\"string\"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var g,f,h,p,k=[],n=sjcl.bitArray;for(p=1;32*k.length<(d||1);p++){e=g=a.encrypt(n.concat(b,[p]));for(f=1;f<c;f++){g=a.encrypt(g);for(h=0;h<g.length;h++)e[h]^=g[h]}k=k.concat(e)}d&&(k=n.clamp(k,d));return k};\n  return sjcl; });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sjcl/sjcl.js\n// module id = 0\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\ndefine(['./hawk', './errors'], function (hawk, ERRORS) {\n  'use strict';\n  /* global XMLHttpRequest */\n\n  /**\n   * @class Request\n   * @constructor\n   * @param {String} baseUri Base URI\n   * @param {Object} xhr XMLHttpRequest constructor\n   * @param {Object} [options={}] Options\n   *   @param {Number} [options.localtimeOffsetMsec]\n   *   Local time offset with the remote auth server's clock\n   */\n  function Request (baseUri, xhr, options) {\n    if (!options) {\n      options = {};\n    }\n    this.baseUri = baseUri;\n    this._localtimeOffsetMsec = options.localtimeOffsetMsec;\n    this.xhr = xhr || XMLHttpRequest;\n    this.timeout = options.timeout || 30 * 1000;\n  }\n\n  /**\n   * @method send\n   * @param {String} path Request path\n   * @param {String} method HTTP Method\n   * @param {Object} credentials HAWK Headers\n   * @param {Object} jsonPayload JSON Payload\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.retrying]\n   *   Flag indicating if the request is a retry\n   *   @param {Array} [options.headers]\n   *   A set of extra headers to add to the request\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  Request.prototype.send = function request(path, method, credentials, jsonPayload, options) {\n    /*eslint complexity: [2, 8] */\n    var xhr = new this.xhr();\n    var uri = this.baseUri + path;\n    var payload = null;\n    var self = this;\n    options = options || {};\n\n    if (jsonPayload) {\n      payload = JSON.stringify(jsonPayload);\n    }\n\n    try {\n      xhr.open(method, uri);\n    } catch (e) {\n      return Promise.reject({ error: 'Unknown error', message: e.toString(), errno: 999 });\n    }\n\n    return new Promise(function (resolve, reject) {\n      xhr.timeout = self.timeout;\n\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var result = xhr.responseText;\n          try {\n            result = JSON.parse(xhr.responseText);\n          } catch (e) { }\n\n          if (result.errno) {\n            // Try to recover from a timeskew error and not already tried\n            if (result.errno === ERRORS.INVALID_TIMESTAMP && !options.retrying) {\n              var serverTime = result.serverTime;\n              self._localtimeOffsetMsec = (serverTime * 1000) - new Date().getTime();\n\n              // add to options that the request is retrying\n              options.retrying = true;\n\n              return self.send(path, method, credentials, jsonPayload, options)\n                .then(resolve, reject);\n\n            } else {\n              return reject(result);\n            }\n          }\n\n          if (typeof xhr.status === 'undefined' || xhr.status !== 200) {\n            if (result.length === 0) {\n              return reject({ error: 'Timeout error', errno: 999 });\n            } else {\n              return reject({ error: 'Unknown error', message: result, errno: 999, code: xhr.status });\n            }\n          }\n\n          resolve(result);\n        }\n      };\n\n      // calculate Hawk header if credentials are supplied\n      if (credentials) {\n        var hawkHeader = hawk.client.header(uri, method, {\n                            credentials: credentials,\n                            payload: payload,\n                            contentType: 'application/json',\n                            localtimeOffsetMsec: self._localtimeOffsetMsec || 0\n                          });\n        xhr.setRequestHeader('authorization', hawkHeader.field);\n      }\n\n      xhr.setRequestHeader('Content-Type', 'application/json');\n\n      if (options && options.headers) {\n        // set extra headers for this request\n        for (var header in options.headers) {\n          xhr.setRequestHeader(header, options.headers[header]);\n        }\n      }\n\n      xhr.send(payload);\n    });\n  };\n\n  return Request;\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/lib/request.js\n// module id = 1\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\ndefine([], function () {\n  return {\n    INVALID_TIMESTAMP: 111,\n    INCORRECT_EMAIL_CASE: 120\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/lib/errors.js\n// module id = 2\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\ndefine(['sjcl'], function (sjcl) {\n  'use strict';\n\n  /**\n   * hkdf - The HMAC-based Key Derivation Function\n   * based on https://github.com/mozilla/node-hkdf\n   *\n   * @class hkdf\n   * @param {bitArray} ikm Initial keying material\n   * @param {bitArray} info Key derivation data\n   * @param {bitArray} salt Salt\n   * @param {integer} length Length of the derived key in bytes\n   * @return promise object- It will resolve with `output` data\n   */\n  function hkdf(ikm, info, salt, length) {\n\n    var mac = new sjcl.misc.hmac(salt, sjcl.hash.sha256);\n    mac.update(ikm);\n\n    // compute the PRK\n    var prk = mac.digest();\n\n    // hash length is 32 because only sjcl.hash.sha256 is used at this moment\n    var hashLength = 32;\n    var num_blocks = Math.ceil(length / hashLength);\n    var prev = sjcl.codec.hex.toBits('');\n    var output = '';\n\n    for (var i = 0; i < num_blocks; i++) {\n      var hmac = new sjcl.misc.hmac(prk, sjcl.hash.sha256);\n\n      var input = sjcl.bitArray.concat(\n        sjcl.bitArray.concat(prev, info),\n        sjcl.codec.utf8String.toBits((String.fromCharCode(i + 1)))\n      );\n\n      hmac.update(input);\n\n      prev = hmac.digest();\n      output += sjcl.codec.hex.fromBits(prev);\n    }\n\n    var truncated = sjcl.bitArray.clamp(sjcl.codec.hex.toBits(output), length * 8);\n\n    return Promise.resolve(truncated);\n  }\n\n  return hkdf;\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/lib/hkdf.js\n// module id = 3\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\ndefine([\n  'es6-promise',\n  'sjcl',\n  './lib/credentials',\n  './lib/errors',\n  './lib/hawkCredentials',\n  './lib/metricsContext',\n  './lib/request',\n], function (ES6Promise, sjcl, credentials, ERRORS, hawkCredentials, metricsContext, Request) {\n  'use strict';\n\n  // polyfill ES6 promises on browsers that do not support them.\n  ES6Promise.polyfill();\n\n  var VERSION = 'v1';\n  var uriVersionRegExp = new RegExp('/' + VERSION + '$');\n  var HKDF_SIZE = 2 * 32;\n\n  function isUndefined(val) {\n    return typeof val === 'undefined';\n  }\n\n  function isNull(val) {\n    return val === null;\n  }\n\n  function isEmptyObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]' && ! Object.keys(val).length;\n  }\n\n  function isEmptyString(val) {\n    return val === '';\n  }\n\n  function required(val, name) {\n    if (isUndefined(val) ||\n        isNull(val) ||\n        isEmptyObject(val) ||\n        isEmptyString(val)) {\n      throw new Error('Missing ' + name);\n    }\n  }\n\n  /**\n   * @class FxAccountClient\n   * @constructor\n   * @param {String} uri Auth Server URI\n   * @param {Object} config Configuration\n   */\n  function FxAccountClient(uri, config) {\n    if (! uri && ! config) {\n      throw new Error('Firefox Accounts auth server endpoint or configuration object required.');\n    }\n\n    if (typeof uri !== 'string') {\n      config = uri || {};\n      uri = config.uri;\n    }\n\n    if (typeof config === 'undefined') {\n      config = {};\n    }\n\n    if (! uri) {\n      throw new Error('FxA auth server uri not set.');\n    }\n\n    if (!uriVersionRegExp.test(uri)) {\n      uri = uri + '/' + VERSION;\n    }\n\n    this.request = new Request(uri, config.xhr, { localtimeOffsetMsec: config.localtimeOffsetMsec });\n  }\n\n  FxAccountClient.VERSION = VERSION;\n\n  /**\n   * @method signUp\n   * @param {String} email Email input\n   * @param {String} password Password input\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get the keyFetchToken\n   *   @param {String} [options.service]\n   *   Opaque alphanumeric token to be included in verification links\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.preVerified]\n   *   set email to be verified if possible\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.lang]\n   *   set the language for the 'Accept-Language' header\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.signUp = function (email, password, options) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(password, 'password');\n\n        return credentials.setup(email, password);\n      })\n      .then(\n        function (result) {\n          /*eslint complexity: [2, 13] */\n          var endpoint = '/account/create';\n          var data = {\n            email: result.emailUTF8,\n            authPW: sjcl.codec.hex.fromBits(result.authPW)\n          };\n          var requestOpts = {};\n\n          if (options) {\n            if (options.service) {\n              data.service = options.service;\n            }\n\n            if (options.redirectTo) {\n              data.redirectTo = options.redirectTo;\n            }\n\n            // preVerified is used for unit/functional testing\n            if (options.preVerified) {\n              data.preVerified = options.preVerified;\n            }\n\n            if (options.resume) {\n              data.resume = options.resume;\n            }\n\n            if (options.keys) {\n              endpoint += '?keys=true';\n            }\n\n            if (options.lang) {\n              requestOpts.headers = {\n                'Accept-Language': options.lang\n              };\n            }\n\n            if (options.metricsContext) {\n              data.metricsContext = metricsContext.marshall(options.metricsContext);\n            }\n          }\n\n          return self.request.send(endpoint, 'POST', null, data, requestOpts)\n            .then(\n              function(accountData) {\n                if (options && options.keys) {\n                  accountData.unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);\n                }\n                return accountData;\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * @method signIn\n   * @param {String} email Email input\n   * @param {String} password Password input\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get the keyFetchToken\n   *   @param {Boolean} [options.skipCaseError]\n   *   If `true`, the request will skip the incorrect case error\n   *   @param {String} [options.service]\n   *   Service being signed into\n   *   @param {String} [options.reason]\n   *   Reason for sign in. Can be one of: `signin`, `password_check`,\n   *   `password_change`, `password_reset`\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.originalLoginEmail]\n   *   If retrying after an \"incorrect email case\" error, this specifies\n   *   the email address as originally entered by the user.\n   *   @param {String} [options.verificationMethod]\n   *   Request a specific verification method be used for verifying the session,\n   *   e.g. 'email-2fa' or 'totp-2fa'.\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   *   @param {String} [options.unblockCode]\n   *   Login unblock code.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.signIn = function (email, password, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(password, 'password');\n\n        return credentials.setup(email, password);\n      })\n      .then(\n        function (result) {\n          var endpoint = '/account/login';\n\n          if (options.keys) {\n            endpoint += '?keys=true';\n          }\n\n          var data = {\n            email: result.emailUTF8,\n            authPW: sjcl.codec.hex.fromBits(result.authPW)\n          };\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n\n          if (options.reason) {\n            data.reason = options.reason;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.unblockCode) {\n            data.unblockCode = options.unblockCode;\n          }\n\n          if (options.originalLoginEmail) {\n            data.originalLoginEmail = options.originalLoginEmail;\n          }\n\n          if (options.verificationMethod) {\n            data.verificationMethod = options.verificationMethod;\n          }\n\n          return self.request.send(endpoint, 'POST', null, data)\n            .then(\n              function(accountData) {\n                if (options.keys) {\n                  accountData.unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);\n                }\n                return accountData;\n              },\n              function(error) {\n                if (error && error.email && error.errno === ERRORS.INCORRECT_EMAIL_CASE && !options.skipCaseError) {\n                  options.skipCaseError = true;\n                  options.originalLoginEmail = email;\n\n                  return self.signIn(error.email, password, options);\n                } else {\n                  throw error;\n                }\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * @method verifyCode\n   * @param {String} uid Account ID\n   * @param {String} code Verification code\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.service]\n   *   Service being signed into\n   *   @param {String} [options.reminder]\n   *   Reminder that was used to verify the account\n   *   @param {String} [options.type]\n   *   Type of code being verified, only supports `secondary` otherwise will verify account/sign-in\n   *   @param {Boolean} [options.marketingOptIn]\n   *   If `true`, notifies marketing of opt-in intent.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.verifyCode = function(uid, code, options) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(uid, 'uid');\n        required(code, 'verify code');\n\n        var data = {\n          uid: uid,\n          code: code\n        };\n\n        if (options) {\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.reminder) {\n            data.reminder = options.reminder;\n          }\n\n          if (options.type) {\n            data.type = options.type;\n          }\n\n          if (options.marketingOptIn) {\n            data.marketingOptIn = true;\n          }\n        }\n\n        return self.request.send('/recovery_email/verify_code', 'POST', null, data);\n      });\n  };\n\n  FxAccountClient.prototype.verifyTokenCode = function(sessionToken, uid, code) {\n    var self = this;\n\n    required(uid, 'uid');\n    required(code, 'verify token code');\n    required(sessionToken, 'sessionToken');\n\n    return Promise.resolve()\n      .then(function () {\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var data = {\n          uid: uid,\n          code: code\n        };\n\n        return self.request.send('/session/verify/token', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * @method recoveryEmailStatus\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.recoveryEmailStatus = function(sessionToken) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/recovery_email/status', 'GET', creds);\n      });\n  };\n\n  /**\n   * Re-sends a verification code to the account's recovery email address.\n   *\n   * @method recoveryEmailResendCode\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.email]\n   *   Code will be resent to this email, only used for secondary email codes\n   *   @param {String} [options.service]\n   *   Opaque alphanumeric token to be included in verification links\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.type]\n   *   Specifies the type of code to send, currently only supported type is\n   *   `upgradeSession`.\n   *   @param {String} [options.lang]\n   *   set the language for the 'Accept-Language' header\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.recoveryEmailResendCode = function(sessionToken, options) {\n    var self = this;\n    var data = {};\n    var requestOpts = {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        if (options) {\n          if (options.email) {\n            data.email = options.email;\n          }\n\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.type) {\n            data.type = options.type;\n          }\n\n          if (options.lang) {\n            requestOpts.headers = {\n              'Accept-Language': options.lang\n            };\n          }\n        }\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/recovery_email/resend_code', 'POST', creds, data, requestOpts);\n      });\n  };\n\n  /**\n   * Used to ask the server to send a recovery code.\n   * The API returns passwordForgotToken to the client.\n   *\n   * @method passwordForgotSendCode\n   * @param {String} email\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.service]\n   *   Opaque alphanumeric token to be included in verification links\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.lang]\n   *   set the language for the 'Accept-Language' header\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordForgotSendCode = function(email, options) {\n    var self = this;\n    var data = {\n      email: email\n    };\n    var requestOpts = {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n\n        if (options) {\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.lang) {\n            requestOpts.headers = {\n              'Accept-Language': options.lang\n            };\n          }\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n        }\n\n        return self.request.send('/password/forgot/send_code', 'POST', null, data, requestOpts);\n      });\n  };\n\n  /**\n   * Re-sends a verification code to the account's recovery email address.\n   * HAWK-authenticated with the passwordForgotToken.\n   *\n   * @method passwordForgotResendCode\n   * @param {String} email\n   * @param {String} passwordForgotToken\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.service]\n   *   Opaque alphanumeric token to be included in verification links\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.lang]\n   *   set the language for the 'Accept-Language' header\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordForgotResendCode = function(email, passwordForgotToken, options) {\n    var self = this;\n    var data = {\n      email: email\n    };\n    var requestOpts = {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(passwordForgotToken, 'passwordForgotToken');\n\n        if (options) {\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.lang) {\n            requestOpts.headers = {\n              'Accept-Language': options.lang\n            };\n          }\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n        }\n\n        return hawkCredentials(passwordForgotToken, 'passwordForgotToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/password/forgot/resend_code', 'POST', creds, data, requestOpts);\n      });\n  };\n\n  /**\n   * Submits the verification token to the server.\n   * The API returns accountResetToken to the client.\n   * HAWK-authenticated with the passwordForgotToken.\n   *\n   * @method passwordForgotVerifyCode\n   * @param {String} code\n   * @param {String} passwordForgotToken\n   * @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordForgotVerifyCode = function(code, passwordForgotToken, options) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(code, 'reset code');\n        required(passwordForgotToken, 'passwordForgotToken');\n\n        return hawkCredentials(passwordForgotToken, 'passwordForgotToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          code: code\n        };\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return self.request.send('/password/forgot/verify_code', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Returns the status for the passwordForgotToken.\n   * If the request returns a success response, the token has not yet been consumed.\n\n   * @method passwordForgotStatus\n   * @param {String} passwordForgotToken\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordForgotStatus = function(passwordForgotToken) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(passwordForgotToken, 'passwordForgotToken');\n\n        return hawkCredentials(passwordForgotToken, 'passwordForgotToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/password/forgot/status', 'GET', creds);\n      });\n  };\n\n  /**\n   * The API returns reset result to the client.\n   * HAWK-authenticated with accountResetToken\n   *\n   * @method accountReset\n   * @param {String} email\n   * @param {String} newPassword\n   * @param {String} accountResetToken\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, a new `keyFetchToken` is provisioned. `options.sessionToken`\n   *   is required if `options.keys` is true.\n   *   @param {Boolean} [options.sessionToken]\n   *   If `true`, a new `sessionToken` is provisioned.\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.accountReset = function(email, newPassword, accountResetToken, options) {\n    var self = this;\n    var data = {};\n    var unwrapBKey;\n\n    options = options || {};\n\n    if (options.sessionToken) {\n      data.sessionToken = options.sessionToken;\n    }\n\n    if (options.metricsContext) {\n      data.metricsContext = metricsContext.marshall(options.metricsContext);\n    }\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(newPassword, 'new password');\n        required(accountResetToken, 'accountResetToken');\n\n        if (options.keys) {\n          required(options.sessionToken, 'sessionToken');\n        }\n\n        return credentials.setup(email, newPassword);\n      })\n      .then(\n        function (result) {\n          if (options.keys) {\n            unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);\n          }\n\n          data.authPW = sjcl.codec.hex.fromBits(result.authPW);\n\n          return hawkCredentials(accountResetToken, 'accountResetToken',  HKDF_SIZE);\n        }\n      ).then(\n        function (creds) {\n          var queryParams = '';\n          if (options.keys) {\n            queryParams = '?keys=true';\n          }\n\n          var endpoint = '/account/reset' + queryParams;\n          return self.request.send(endpoint, 'POST', creds, data)\n            .then(\n              function(accountData) {\n                if (options.keys && accountData.keyFetchToken) {\n                  accountData.unwrapBKey = unwrapBKey;\n                }\n\n                return accountData;\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * Get the base16 bundle of encrypted kA|wrapKb.\n   *\n   * @method accountKeys\n   * @param {String} keyFetchToken\n   * @param {String} oldUnwrapBKey\n   * @return {Promise} A promise that will be fulfilled with JSON of {kA, kB}  of the key bundle\n   */\n  FxAccountClient.prototype.accountKeys = function(keyFetchToken, oldUnwrapBKey) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(keyFetchToken, 'keyFetchToken');\n        required(oldUnwrapBKey, 'oldUnwrapBKey');\n\n        return hawkCredentials(keyFetchToken, 'keyFetchToken',  3 * 32);\n      })\n      .then(function(creds) {\n        var bundleKey = sjcl.codec.hex.fromBits(creds.bundleKey);\n\n        return self.request.send('/account/keys', 'GET', creds)\n          .then(\n            function(payload) {\n\n              return credentials.unbundleKeyFetchResponse(bundleKey, payload.bundle);\n            });\n      })\n      .then(function(keys) {\n        return {\n          kB: sjcl.codec.hex.fromBits(\n            credentials.xor(\n              sjcl.codec.hex.toBits(keys.wrapKB),\n              sjcl.codec.hex.toBits(oldUnwrapBKey)\n            )\n          ),\n          kA: keys.kA\n        };\n      });\n  };\n\n  /**\n   * This deletes the account completely. All stored data is erased.\n   *\n   * @method accountDestroy\n   * @param {String} email Email input\n   * @param {String} password Password input\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.skipCaseError]\n   *   If `true`, the request will skip the incorrect case error\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.accountDestroy = function(email, password, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(password, 'password');\n\n        return credentials.setup(email, password);\n      })\n      .then(\n        function (result) {\n          var data = {\n            email: result.emailUTF8,\n            authPW: sjcl.codec.hex.fromBits(result.authPW)\n          };\n\n          return self.request.send('/account/destroy', 'POST', null, data)\n            .then(\n              function(response) {\n                return response;\n              },\n              function(error) {\n                // if incorrect email case error\n                if (error && error.email && error.errno === ERRORS.INCORRECT_EMAIL_CASE && !options.skipCaseError) {\n                  options.skipCaseError = true;\n\n                  return self.accountDestroy(error.email, password, options);\n                } else {\n                  throw error;\n                }\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * Gets the status of an account by uid.\n   *\n   * @method accountStatus\n   * @param {String} uid User account id\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.accountStatus = function(uid) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(uid, 'uid');\n\n        return self.request.send('/account/status?uid=' + uid, 'GET');\n      });\n  };\n\n  /**\n   * Gets the status of an account by email.\n   *\n   * @method accountStatusByEmail\n   * @param {String} email User account email\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.accountStatusByEmail = function(email) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n\n        return self.request.send('/account/status', 'POST', null, {email: email});\n      });\n  };\n\n  /**\n   * Destroys this session, by invalidating the sessionToken.\n   *\n   * @method sessionDestroy\n   * @param {String} sessionToken User session token\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.customSessionToken] Override which session token to destroy for this same user\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sessionDestroy = function(sessionToken, options) {\n    var self = this;\n    var data = {};\n    options = options || {};\n\n    if (options.customSessionToken) {\n      data.customSessionToken = options.customSessionToken;\n    }\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/session/destroy', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Responds successfully if the session status is valid, requires the sessionToken.\n   *\n   * @method sessionStatus\n   * @param {String} sessionToken User session token\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sessionStatus = function(sessionToken) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return self.request.send('/session/status', 'GET', creds);\n      });\n  };\n\n  /**\n   * @method sessionReauth\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @param {String} email Email input\n   * @param {String} password Password input\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get the keyFetchToken\n   *   @param {Boolean} [options.skipCaseError]\n   *   If `true`, the request will skip the incorrect case error\n   *   @param {String} [options.service]\n   *   Service being accessed that needs reauthentication\n   *   @param {String} [options.reason]\n   *   Reason for reauthentication. Can be one of: `signin`, `password_check`,\n   *   `password_change`, `password_reset`\n   *   @param {String} [options.redirectTo]\n   *   a URL that the client should be redirected to after handling the request\n   *   @param {String} [options.resume]\n   *   Opaque url-encoded string that will be included in the verification link\n   *   as a querystring parameter, useful for continuing an OAuth flow for\n   *   example.\n   *   @param {String} [options.originalLoginEmail]\n   *   If retrying after an \"incorrect email case\" error, this specifies\n   *   the email address as originally entered by the user.\n   *   @param {String} [options.verificationMethod]\n   *   Request a specific verification method be used for verifying the session,\n   *   e.g. 'email-2fa' or 'totp-2fa'.\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   *   @param {String} [options.unblockCode]\n   *   Login unblock code.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sessionReauth = function (sessionToken, email, password, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(email, 'email');\n        required(password, 'password');\n\n        return credentials.setup(email, password);\n      })\n      .then(\n        function (result) {\n          var endpoint = '/session/reauth';\n\n          if (options.keys) {\n            endpoint += '?keys=true';\n          }\n\n          var data = {\n            email: result.emailUTF8,\n            authPW: sjcl.codec.hex.fromBits(result.authPW)\n          };\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n\n          if (options.reason) {\n            data.reason = options.reason;\n          }\n\n          if (options.redirectTo) {\n            data.redirectTo = options.redirectTo;\n          }\n\n          if (options.resume) {\n            data.resume = options.resume;\n          }\n\n          if (options.service) {\n            data.service = options.service;\n          }\n\n          if (options.unblockCode) {\n            data.unblockCode = options.unblockCode;\n          }\n\n          if (options.originalLoginEmail) {\n            data.originalLoginEmail = options.originalLoginEmail;\n          }\n\n          if (options.verificationMethod) {\n            data.verificationMethod = options.verificationMethod;\n          }\n\n          return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE)\n            .then(function (creds) {\n              return self.request.send(endpoint, 'POST', creds, data);\n            })\n            .then(\n              function(accountData) {\n                if (options.keys) {\n                  accountData.unwrapBKey = sjcl.codec.hex.fromBits(result.unwrapBKey);\n                }\n                return accountData;\n              },\n              function(error) {\n                if (error && error.email && error.errno === ERRORS.INCORRECT_EMAIL_CASE && !options.skipCaseError) {\n                  options.skipCaseError = true;\n                  options.originalLoginEmail = email;\n\n                  return self.sessionReauth(sessionToken, error.email, password, options);\n                } else {\n                  throw error;\n                }\n              }\n            );\n        }\n      );\n  };\n\n  /**\n   * Sign a BrowserID public key\n   *\n   * @method certificateSign\n   * @param {String} sessionToken User session token\n   * @param {Object} publicKey The key to sign\n   * @param {int} duration Time interval from now when the certificate will expire in milliseconds\n   * @param {Object} [options={}] Options\n   *   @param {String} [service=''] The requesting service, sent via the query string\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.certificateSign = function(sessionToken, publicKey, duration, options) {\n    var self = this;\n    var data = {\n      publicKey: publicKey,\n      duration: duration\n    };\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(publicKey, 'publicKey');\n        required(duration, 'duration');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        options = options || {};\n\n        var queryString = '';\n        if (options.service) {\n          queryString = '?service=' + encodeURIComponent(options.service);\n        }\n\n        return self.request.send('/certificate/sign' + queryString, 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Change the password from one known value to another.\n   *\n   * @method passwordChange\n   * @param {String} email\n   * @param {String} oldPassword\n   * @param {String} newPassword\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get a new keyFetchToken\n   *   @param {String} [options.sessionToken]\n   *   If a `sessionToken` is passed, a new sessionToken will be returned\n   *   with the same `verified` status as the existing sessionToken.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.passwordChange = function(email, oldPassword, newPassword, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(oldPassword, 'old password');\n        required(newPassword, 'new password');\n\n        return self._passwordChangeStart(email, oldPassword);\n      })\n      .then(function (credentials) {\n\n        var oldCreds = credentials;\n        var emailToHashWith = credentials.emailToHashWith || email;\n\n        return self._passwordChangeKeys(oldCreds)\n          .then(function (keys) {\n\n            return self._passwordChangeFinish(emailToHashWith, newPassword, oldCreds, keys, options);\n          });\n      });\n\n  };\n\n  /**\n   * First step to change the password.\n   *\n   * @method passwordChangeStart\n   * @private\n   * @param {String} email\n   * @param {String} oldPassword\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.skipCaseError]\n   *   If `true`, the request will skip the incorrect case error\n   * @return {Promise} A promise that will be fulfilled with JSON of `xhr.responseText` and `oldUnwrapBKey`\n   */\n  FxAccountClient.prototype._passwordChangeStart = function(email, oldPassword, options) {\n    var self = this;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(oldPassword, 'old password');\n\n        return credentials.setup(email, oldPassword);\n      })\n      .then(function (oldCreds) {\n        var data = {\n          email: oldCreds.emailUTF8,\n          oldAuthPW: sjcl.codec.hex.fromBits(oldCreds.authPW)\n        };\n\n        return self.request.send('/password/change/start', 'POST', null, data)\n          .then(\n            function(passwordData) {\n              passwordData.oldUnwrapBKey = sjcl.codec.hex.fromBits(oldCreds.unwrapBKey);\n\n              // Similar to password reset, this keeps the contract that we always\n              // hash passwords with the original account email.\n              passwordData.emailToHashWith = email;\n              return passwordData;\n            },\n            function(error) {\n              // if incorrect email case error\n              if (error && error.email && error.errno === ERRORS.INCORRECT_EMAIL_CASE && !options.skipCaseError) {\n                options.skipCaseError = true;\n\n                return self._passwordChangeStart(error.email, oldPassword, options);\n              } else {\n                throw error;\n              }\n            }\n          );\n      });\n  };\n\n  function checkCreds(creds) {\n    required(creds, 'credentials');\n    required(creds.oldUnwrapBKey, 'credentials.oldUnwrapBKey');\n    required(creds.keyFetchToken, 'credentials.keyFetchToken');\n    required(creds.passwordChangeToken, 'credentials.passwordChangeToken');\n  }\n\n  /**\n   * Second step to change the password.\n   *\n   * @method _passwordChangeKeys\n   * @private\n   * @param {Object} oldCreds This object should consists of `oldUnwrapBKey`, `keyFetchToken` and `passwordChangeToken`.\n   * @return {Promise} A promise that will be fulfilled with JSON of `xhr.responseText`\n   */\n  FxAccountClient.prototype._passwordChangeKeys = function(oldCreds) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        checkCreds(oldCreds);\n      })\n      .then(function () {\n        return self.accountKeys(oldCreds.keyFetchToken, oldCreds.oldUnwrapBKey);\n      });\n  };\n\n  /**\n   * Third step to change the password.\n   *\n   * @method _passwordChangeFinish\n   * @private\n   * @param {String} email\n   * @param {String} newPassword\n   * @param {Object} oldCreds This object should consists of `oldUnwrapBKey`, `keyFetchToken` and `passwordChangeToken`.\n   * @param {Object} keys This object should contain the unbundled keys\n   * @param {Object} [options={}] Options\n   *   @param {Boolean} [options.keys]\n   *   If `true`, calls the API with `?keys=true` to get the keyFetchToken\n   *   @param {String} [options.sessionToken]\n   *   If a `sessionToken` is passed, a new sessionToken will be returned\n   *   with the same `verified` status as the existing sessionToken.\n   * @return {Promise} A promise that will be fulfilled with JSON of `xhr.responseText`\n   */\n  FxAccountClient.prototype._passwordChangeFinish = function(email, newPassword, oldCreds, keys, options) {\n    options = options || {};\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n        required(newPassword, 'new password');\n        checkCreds(oldCreds);\n        required(keys, 'keys');\n        required(keys.kB, 'keys.kB');\n\n        var defers = [];\n        defers.push(credentials.setup(email, newPassword));\n        defers.push(hawkCredentials(oldCreds.passwordChangeToken, 'passwordChangeToken',  HKDF_SIZE));\n\n        if (options.sessionToken) {\n          // Unbundle session data to get session id\n          defers.push(hawkCredentials(options.sessionToken, 'sessionToken',  HKDF_SIZE));\n        }\n\n        return Promise.all(defers);\n      })\n      .then(function (results) {\n        var newCreds = results[0];\n        var hawkCreds = results[1];\n        var sessionData = results[2];\n        var newWrapKb = sjcl.codec.hex.fromBits(\n          credentials.xor(\n            sjcl.codec.hex.toBits(keys.kB),\n            newCreds.unwrapBKey\n          )\n        );\n\n        var queryParams = '';\n        if (options.keys) {\n          queryParams = '?keys=true';\n        }\n\n        var sessionTokenId;\n        if (sessionData && sessionData.id) {\n          sessionTokenId = sessionData.id;\n        }\n\n        return self.request.send('/password/change/finish' + queryParams, 'POST', hawkCreds, {\n          wrapKb: newWrapKb,\n          authPW: sjcl.codec.hex.fromBits(newCreds.authPW),\n          sessionToken: sessionTokenId\n        })\n        .then(function (accountData) {\n          if (options.keys && accountData.keyFetchToken) {\n            accountData.unwrapBKey = sjcl.codec.hex.fromBits(newCreds.unwrapBKey);\n          }\n          return accountData;\n        });\n      });\n  };\n\n  /**\n   * Get 32 bytes of random data. This should be combined with locally-sourced entropy when creating salts, etc.\n   *\n   * @method getRandomBytes\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.getRandomBytes = function() {\n\n    return this.request.send('/get_random_bytes', 'POST');\n  };\n\n  /**\n   * Add a new device\n   *\n   * @method deviceRegister\n   * @param {String} sessionToken User session token\n   * @param {String} deviceName Name of device\n   * @param {String} deviceType Type of device (mobile|desktop)\n   * @param {Object} [options={}] Options\n   *   @param {string} [options.deviceCallback] Device's push endpoint.\n   *   @param {string} [options.devicePublicKey] Public key used to encrypt push messages.\n   *   @param {string} [options.deviceAuthKey] Authentication secret used to encrypt push messages.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.deviceRegister = function (sessionToken, deviceName, deviceType, options) {\n    var request = this.request;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(deviceName, 'deviceName');\n        required(deviceType, 'deviceType');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          name: deviceName,\n          type: deviceType\n        };\n\n        if (options.deviceCallback) {\n          data.pushCallback = options.deviceCallback;\n        }\n\n        if (options.devicePublicKey && options.deviceAuthKey) {\n          data.pushPublicKey = options.devicePublicKey;\n          data.pushAuthKey = options.deviceAuthKey;\n        }\n\n        return request.send('/account/device', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Update the name of an existing device\n   *\n   * @method deviceUpdate\n   * @param {String} sessionToken User session token\n   * @param {String} deviceId User-unique identifier of device\n   * @param {String} deviceName Name of device\n   * @param {Object} [options={}] Options\n   *   @param {string} [options.deviceCallback] Device's push endpoint.\n   *   @param {string} [options.devicePublicKey] Public key used to encrypt push messages.\n   *   @param {string} [options.deviceAuthKey] Authentication secret used to encrypt push messages.\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.deviceUpdate = function (sessionToken, deviceId, deviceName, options) {\n    var request = this.request;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(deviceId, 'deviceId');\n        required(deviceName, 'deviceName');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          id: deviceId,\n          name: deviceName\n        };\n\n        if (options.deviceCallback) {\n          data.pushCallback = options.deviceCallback;\n        }\n\n        if (options.devicePublicKey && options.deviceAuthKey) {\n          data.pushPublicKey = options.devicePublicKey;\n          data.pushAuthKey = options.deviceAuthKey;\n        }\n\n        return request.send('/account/device', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Unregister an existing device\n   *\n   * @method deviceDestroy\n   * @param {String} sessionToken Session token obtained from signIn\n   * @param {String} deviceId User-unique identifier of device\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.deviceDestroy = function (sessionToken, deviceId) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(deviceId, 'deviceId');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          id: deviceId\n        };\n\n        return request.send('/account/device/destroy', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Get a list of all devices for a user\n   *\n   * @method deviceList\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.deviceList = function (sessionToken) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/account/devices', 'GET', creds);\n      });\n  };\n\n  /**\n   * Get a list of user's sessions\n   *\n   * @method sessions\n   * @param {String} sessionToken sessionToken obtained from signIn\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sessions = function (sessionToken) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/account/sessions', 'GET', creds);\n      });\n  };\n\n  /**\n   * Send an unblock code\n   *\n   * @method sendUnblockCode\n   * @param {String} email email where to send the login authorization code\n   * @param {Object} [options={}] Options\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.sendUnblockCode = function (email, options) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(email, 'email');\n\n        var data = {\n          email: email\n        };\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return self.request.send('/account/login/send_unblock_code', 'POST', null, data);\n      });\n  };\n\n  /**\n   * Reject a login unblock code. Code will be deleted from the server\n   * and will not be able to be used again.\n   *\n   * @method rejectLoginAuthorizationCode\n   * @param {String} uid Account ID\n   * @param {String} unblockCode unblock code\n   * @return {Promise} A promise that will be fulfilled with JSON `xhr.responseText` of the request\n   */\n  FxAccountClient.prototype.rejectUnblockCode = function (uid, unblockCode) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(uid, 'uid');\n        required(unblockCode, 'unblockCode');\n\n        var data = {\n          uid: uid,\n          unblockCode: unblockCode\n        };\n\n        return self.request.send('/account/login/reject_unblock_code', 'POST', null, data);\n      });\n  };\n\n  /**\n   * Send an sms.\n   *\n   * @method sendSms\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} phoneNumber Phone number sms will be sent to\n   * @param {String} messageId Corresponding message id that will be sent\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.lang] Language that sms will be sent in\n   *   @param {Array} [options.features] Array of features to be enabled for the request\n   *   @param {Object} [options.metricsContext={}] Metrics context metadata\n   *     @param {String} options.metricsContext.deviceId identifier for the current device\n   *     @param {String} options.metricsContext.flowId identifier for the current event flow\n   *     @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *     @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *     @param {Number} options.metricsContext.utmContent content identifier\n   *     @param {Number} options.metricsContext.utmMedium acquisition medium\n   *     @param {Number} options.metricsContext.utmSource traffic source\n   *     @param {Number} options.metricsContext.utmTerm search terms\n   */\n  FxAccountClient.prototype.sendSms = function (sessionToken, phoneNumber, messageId, options) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(phoneNumber, 'phoneNumber');\n        required(messageId, 'messageId');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          phoneNumber: phoneNumber,\n          messageId: messageId\n        };\n        var requestOpts = {};\n\n        if (options) {\n          if (options.lang) {\n            requestOpts.headers = {\n              'Accept-Language': options.lang\n            };\n          }\n\n          if (options.features) {\n            data.features = options.features;\n          }\n\n          if (options.metricsContext) {\n            data.metricsContext = metricsContext.marshall(options.metricsContext);\n          }\n        }\n\n        return request.send('/sms', 'POST', creds, data, requestOpts);\n      });\n  };\n\n  /**\n   * Get SMS status for the current user.\n   *\n   * @method smsStatus\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {Object} [options={}] Options\n   *   @param {String} [options.country] country Country to force for testing.\n   */\n  FxAccountClient.prototype.smsStatus = function (sessionToken, options) {\n    var request = this.request;\n    options = options || {};\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var url = '/sms/status';\n        if (options.country) {\n          url += '?country=' + encodeURIComponent(options.country);\n        }\n        return request.send(url, 'GET', creds);\n      });\n  };\n\n  /**\n   * Consume a signinCode.\n   *\n   * @method consumeSigninCode\n   * @param {String} code The signinCode entered by the user\n   * @param {String} flowId Identifier for the current event flow\n   * @param {Number} flowBeginTime Timestamp for the flow.begin event\n   * @param {String} [deviceId] Identifier for the current device\n   */\n  FxAccountClient.prototype.consumeSigninCode = function (code, flowId, flowBeginTime, deviceId) {\n    var self = this;\n\n    return Promise.resolve()\n      .then(function () {\n        required(code, 'code');\n        required(flowId, 'flowId');\n        required(flowBeginTime, 'flowBeginTime');\n\n        return self.request.send('/signinCodes/consume', 'POST', null, {\n          code: code,\n          metricsContext: {\n            deviceId: deviceId,\n            flowId: flowId,\n            flowBeginTime: flowBeginTime\n          }\n        });\n      });\n  };\n\n  /**\n   * Get the recovery emails associated with the signed in account.\n   *\n   * @method recoveryEmails\n   * @param {String} sessionToken SessionToken obtained from signIn\n   */\n  FxAccountClient.prototype.recoveryEmails = function (sessionToken) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/recovery_emails', 'GET', creds);\n      });\n  };\n\n  /**\n   * Create a new recovery email for the signed in account.\n   *\n   * @method recoveryEmailCreate\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} email new email to be added\n   */\n  FxAccountClient.prototype.recoveryEmailCreate = function (sessionToken, email) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(sessionToken, 'email');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          email: email\n        };\n\n        return request.send('/recovery_email', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Remove the recovery email for the signed in account.\n   *\n   * @method recoveryEmailDestroy\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} email email to be removed\n   */\n  FxAccountClient.prototype.recoveryEmailDestroy = function (sessionToken, email) {\n    var request = this.request;\n\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(sessionToken, 'email');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          email: email\n        };\n\n        return request.send('/recovery_email/destroy', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Changes user's primary email address.\n   *\n   * @method recoveryEmailSetPrimaryEmail\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} email Email that will be the new primary email for user\n   */\n  FxAccountClient.prototype.recoveryEmailSetPrimaryEmail = function (sessionToken, email) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        var data = {\n          email: email\n        };\n        return request.send('/recovery_email/set_primary', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Creates a new TOTP token for the user associated with this session.\n   *\n   * @method createTotpToken\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {Object} [options.metricsContext={}] Metrics context metadata\n   *   @param {String} options.metricsContext.deviceId identifier for the current device\n   *   @param {String} options.metricsContext.flowId identifier for the current event flow\n   *   @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *   @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *   @param {Number} options.metricsContext.utmContent content identifier\n   *   @param {Number} options.metricsContext.utmMedium acquisition medium\n   *   @param {Number} options.metricsContext.utmSource traffic source\n   *   @param {Number} options.metricsContext.utmTerm search terms\n   */\n  FxAccountClient.prototype.createTotpToken = function (sessionToken, options) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken', HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var data = {};\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return request.send('/totp/create', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Deletes this user's TOTP token.\n   *\n   * @method deleteTotpToken\n   * @param {String} sessionToken SessionToken obtained from signIn\n   */\n  FxAccountClient.prototype.deleteTotpToken = function (sessionToken) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/totp/destroy', 'POST', creds, {});\n      });\n  };\n\n  /**\n   * Check to see if the current user has a TOTP token associated with\n   * their account.\n   *\n   * @method checkTotpTokenExists\n   * @param {String} sessionToken SessionToken obtained from signIn\n   */\n  FxAccountClient.prototype.checkTotpTokenExists = function (sessionToken) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken',  HKDF_SIZE);\n      })\n      .then(function(creds) {\n        return request.send('/totp/exists', 'GET', creds);\n      });\n  };\n\n  /**\n   * Verify tokens if using a valid TOTP code.\n   *\n   * @method verifyTotpCode\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} code TOTP code to verif\n   * @param {Object} [options.metricsContext={}] Metrics context metadata\n   *   @param {String} options.metricsContext.deviceId identifier for the current device\n   *   @param {String} options.metricsContext.flowId identifier for the current event flow\n   *   @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *   @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *   @param {Number} options.metricsContext.utmContent content identifier\n   *   @param {Number} options.metricsContext.utmMedium acquisition medium\n   *   @param {Number} options.metricsContext.utmSource traffic source\n   *   @param {Number} options.metricsContext.utmTerm search terms\n   */\n  FxAccountClient.prototype.verifyTotpCode = function (sessionToken, code, options) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(code, 'code');\n\n        return hawkCredentials(sessionToken, 'sessionToken', HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var data = {\n          code: code\n        };\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return request.send('/session/verify/totp', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Replace user's recovery codes.\n   *\n   * @method replaceRecoveryCodes\n   * @param {String} sessionToken SessionToken obtained from signIn\n   */\n  FxAccountClient.prototype.replaceRecoveryCodes = function (sessionToken) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n\n        return hawkCredentials(sessionToken, 'sessionToken', HKDF_SIZE);\n      })\n      .then(function (creds) {\n\n        return request.send('/recoveryCodes', 'GET', creds);\n      });\n  };\n\n  /**\n   * Consume recovery code.\n   *\n   * @method consumeRecoveryCode\n   * @param {String} sessionToken SessionToken obtained from signIn\n   * @param {String} code recovery code\n   * @param {Object} [options.metricsContext={}] Metrics context metadata\n   *   @param {String} options.metricsContext.deviceId identifier for the current device\n   *   @param {String} options.metricsContext.flowId identifier for the current event flow\n   *   @param {Number} options.metricsContext.flowBeginTime flow.begin event time\n   *   @param {Number} options.metricsContext.utmCampaign marketing campaign identifier\n   *   @param {Number} options.metricsContext.utmContent content identifier\n   *   @param {Number} options.metricsContext.utmMedium acquisition medium\n   *   @param {Number} options.metricsContext.utmSource traffic source\n   *   @param {Number} options.metricsContext.utmTerm search terms\n   */\n  FxAccountClient.prototype.consumeRecoveryCode = function (sessionToken, code, options) {\n    var request = this.request;\n    return Promise.resolve()\n      .then(function () {\n        required(sessionToken, 'sessionToken');\n        required(code, 'code');\n\n        return hawkCredentials(sessionToken, 'sessionToken', HKDF_SIZE);\n      })\n      .then(function (creds) {\n        var data = {\n          code: code\n        };\n\n        if (options && options.metricsContext) {\n          data.metricsContext = metricsContext.marshall(options.metricsContext);\n        }\n\n        return request.send('/session/verify/recoveryCode', 'POST', creds, data);\n      });\n  };\n\n  /**\n   * Check for a required argument. Exposed for unit testing.\n   *\n   * @param {Value} val - value to check\n   * @param {String} name - name of value\n   * @throws {Error} if argument is falsey, or an empty object\n   */\n  FxAccountClient.prototype._required = required;\n\n  return FxAccountClient;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/FxAccountClient.js\n// module id = 4\n// module chunks = 0 1","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   4.1.1\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nvar _isArray = undefined;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = undefined;\nvar customSchedulerFn = undefined;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var r = require;\n    var vertx = r('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = undefined;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var _arguments = arguments;\n\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n  if (_state) {\n    (function () {\n      var callback = _arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    })();\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(16);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar GET_THEN_ERROR = new ErrorObject();\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    GET_THEN_ERROR.error = error;\n    return GET_THEN_ERROR;\n  }\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === GET_THEN_ERROR) {\n      reject(promise, GET_THEN_ERROR.error);\n      GET_THEN_ERROR.error = null;\n    } else if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = undefined,\n      callback = undefined,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction ErrorObject() {\n  this.error = null;\n}\n\nvar TRY_CATCH_ERROR = new ErrorObject();\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = undefined,\n      error = undefined,\n      succeeded = undefined,\n      failed = undefined;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value.error = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n      resolve(promise, value);\n    } else if (failed) {\n      reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      reject(promise, value);\n    }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction Enumerator$1(Constructor, input) {\n  this._instanceConstructor = Constructor;\n  this.promise = new Constructor(noop);\n\n  if (!this.promise[PROMISE_ID]) {\n    makePromise(this.promise);\n  }\n\n  if (isArray(input)) {\n    this.length = input.length;\n    this._remaining = input.length;\n\n    this._result = new Array(this.length);\n\n    if (this.length === 0) {\n      fulfill(this.promise, this._result);\n    } else {\n      this.length = this.length || 0;\n      this._enumerate(input);\n      if (this._remaining === 0) {\n        fulfill(this.promise, this._result);\n      }\n    }\n  } else {\n    reject(this.promise, validationError());\n  }\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nEnumerator$1.prototype._enumerate = function (input) {\n  for (var i = 0; this._state === PENDING && i < input.length; i++) {\n    this._eachEntry(input[i], i);\n  }\n};\n\nEnumerator$1.prototype._eachEntry = function (entry, i) {\n  var c = this._instanceConstructor;\n  var resolve$$1 = c.resolve;\n\n  if (resolve$$1 === resolve$1) {\n    var _then = getThen(entry);\n\n    if (_then === then && entry._state !== PENDING) {\n      this._settledAt(entry._state, i, entry._result);\n    } else if (typeof _then !== 'function') {\n      this._remaining--;\n      this._result[i] = entry;\n    } else if (c === Promise$2) {\n      var promise = new c(noop);\n      handleMaybeThenable(promise, entry, _then);\n      this._willSettleAt(promise, i);\n    } else {\n      this._willSettleAt(new c(function (resolve$$1) {\n        return resolve$$1(entry);\n      }), i);\n    }\n  } else {\n    this._willSettleAt(resolve$$1(entry), i);\n  }\n};\n\nEnumerator$1.prototype._settledAt = function (state, i, value) {\n  var promise = this.promise;\n\n  if (promise._state === PENDING) {\n    this._remaining--;\n\n    if (state === REJECTED) {\n      reject(promise, value);\n    } else {\n      this._result[i] = value;\n    }\n  }\n\n  if (this._remaining === 0) {\n    fulfill(promise, this._result);\n  }\n};\n\nEnumerator$1.prototype._willSettleAt = function (promise, i) {\n  var enumerator = this;\n\n  subscribe(promise, undefined, function (value) {\n    return enumerator._settledAt(FULFILLED, i, value);\n  }, function (reason) {\n    return enumerator._settledAt(REJECTED, i, reason);\n  });\n};\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all$1(entries) {\n  return new Enumerator$1(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race$1(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/\nfunction Promise$2(resolver) {\n  this[PROMISE_ID] = nextId();\n  this._result = this._state = undefined;\n  this._subscribers = [];\n\n  if (noop !== resolver) {\n    typeof resolver !== 'function' && needsResolver();\n    this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();\n  }\n}\n\nPromise$2.all = all$1;\nPromise$2.race = race$1;\nPromise$2.resolve = resolve$1;\nPromise$2.reject = reject$1;\nPromise$2._setScheduler = setScheduler;\nPromise$2._setAsap = setAsap;\nPromise$2._asap = asap;\n\nPromise$2.prototype = {\n  constructor: Promise$2,\n\n  /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */\n  then: then,\n\n  /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */\n  'catch': function _catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\n/*global self*/\nfunction polyfill$1() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('polyfill failed because global object is unavailable in this environment');\n        }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n        var promiseToString = null;\n        try {\n            promiseToString = Object.prototype.toString.call(P.resolve());\n        } catch (e) {\n            // silently ignored\n        }\n\n        if (promiseToString === '[object Promise]' && !P.cast) {\n            return;\n        }\n    }\n\n    local.Promise = Promise$2;\n}\n\n// Strange compat..\nPromise$2.polyfill = polyfill$1;\nPromise$2.Promise = Promise$2;\n\nreturn Promise$2;\n\n})));\n\n//# sourceMappingURL=es6-promise.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/es6-promise/dist/es6-promise.js\n// module id = 5\n// module chunks = 0 1","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 6\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\ndefine(['./request', 'sjcl', './hkdf', './pbkdf2'], function (Request, sjcl, hkdf, pbkdf2) {\n  'use strict';\n\n  // Key wrapping and stretching configuration.\n  var NAMESPACE = 'identity.mozilla.com/picl/v1/';\n  var PBKDF2_ROUNDS = 1000;\n  var STRETCHED_PASS_LENGTH_BYTES = 32 * 8;\n\n  var HKDF_SALT = sjcl.codec.hex.toBits('00');\n  var HKDF_LENGTH = 32;\n\n  /**\n   * Key Wrapping with a name\n   *\n   * @method kw\n   * @static\n   * @param {String} name The name of the salt\n   * @return {bitArray} the salt combination with the namespace\n   */\n  function kw(name) {\n    return sjcl.codec.utf8String.toBits(NAMESPACE + name);\n  }\n\n  /**\n   * Key Wrapping with a name and an email\n   *\n   * @method kwe\n   * @static\n   * @param {String} name The name of the salt\n   * @param {String} email The email of the user.\n   * @return {bitArray} the salt combination with the namespace\n   */\n  function kwe(name, email) {\n    return sjcl.codec.utf8String.toBits(NAMESPACE + name + ':' + email);\n  }\n\n  /**\n   * @class credentials\n   * @constructor\n   */\n  return {\n    /**\n     * Setup credentials\n     *\n     * @method setup\n     * @param {String} emailInput\n     * @param {String} passwordInput\n     * @return {Promise} A promise that will be fulfilled with `result` of generated credentials\n     */\n    setup: function (emailInput, passwordInput) {\n      var result = {};\n      var email = kwe('quickStretch', emailInput);\n      var password = sjcl.codec.utf8String.toBits(passwordInput);\n\n      result.emailUTF8 = emailInput;\n      result.passwordUTF8 = passwordInput;\n\n      return pbkdf2.derive(password, email, PBKDF2_ROUNDS, STRETCHED_PASS_LENGTH_BYTES)\n        .then(\n        function (quickStretchedPW) {\n          result.quickStretchedPW = quickStretchedPW;\n\n          return hkdf(quickStretchedPW, kw('authPW'), HKDF_SALT, HKDF_LENGTH)\n            .then(\n            function (authPW) {\n              result.authPW = authPW;\n\n              return hkdf(quickStretchedPW, kw('unwrapBkey'), HKDF_SALT, HKDF_LENGTH);\n            }\n          );\n        }\n      )\n        .then(\n        function (unwrapBKey) {\n          result.unwrapBKey = unwrapBKey;\n          return result;\n        }\n      );\n    },\n    /**\n     * Wrap\n     *\n     * @method wrap\n     * @param {bitArray} bitArray1\n     * @param {bitArray} bitArray2\n     * @return {bitArray} wrap result of the two bitArrays\n     */\n    xor: function (bitArray1, bitArray2) {\n      var result = [];\n\n      for (var i = 0; i < bitArray1.length; i++) {\n        result[i] = bitArray1[i] ^ bitArray2[i];\n      }\n\n      return result;\n    },\n    /**\n     * Unbundle the WrapKB\n     * @param {String} key Bundle Key in hex\n     * @param {String} bundle Key bundle in hex\n     * @returns {*}\n     */\n    unbundleKeyFetchResponse: function (key, bundle) {\n      var self = this;\n      var bitBundle = sjcl.codec.hex.toBits(bundle);\n\n      return this.deriveBundleKeys(key, 'account/keys')\n        .then(\n          function (keys) {\n            var ciphertext = sjcl.bitArray.bitSlice(bitBundle, 0, 8 * 64);\n            var expectedHmac = sjcl.bitArray.bitSlice(bitBundle, 8 * -32);\n            var hmac = new sjcl.misc.hmac(keys.hmacKey, sjcl.hash.sha256);\n            hmac.update(ciphertext);\n\n            if (!sjcl.bitArray.equal(hmac.digest(), expectedHmac)) {\n              throw new Error('Bad HMac');\n            }\n\n            var keyAWrapB = self.xor(sjcl.bitArray.bitSlice(bitBundle, 0, 8 * 64), keys.xorKey);\n\n            return {\n              kA: sjcl.codec.hex.fromBits(sjcl.bitArray.bitSlice(keyAWrapB, 0, 8 * 32)),\n              wrapKB: sjcl.codec.hex.fromBits(sjcl.bitArray.bitSlice(keyAWrapB, 8 * 32))\n            };\n          }\n        );\n    },\n    /**\n     * Derive the HMAC and XOR keys required to encrypt a given size of payload.\n     * @param {String} key Hex Bundle Key\n     * @param {String} keyInfo Bundle Key Info\n     * @returns {Object} hmacKey, xorKey\n     */\n    deriveBundleKeys: function(key, keyInfo) {\n      var bitKeyInfo = kw(keyInfo);\n      var salt = sjcl.codec.hex.toBits('');\n      key = sjcl.codec.hex.toBits(key);\n\n      return hkdf(key, bitKeyInfo, salt, 3 * 32)\n        .then(\n          function (keyMaterial) {\n\n            return {\n              hmacKey: sjcl.bitArray.bitSlice(keyMaterial, 0, 8 * 32),\n              xorKey: sjcl.bitArray.bitSlice(keyMaterial, 8 * 32)\n            };\n          }\n        );\n    }\n  };\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/lib/credentials.js\n// module id = 8\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\ndefine(['sjcl'], function (sjcl) {\n  'use strict';\n\n  /*\n   HTTP Hawk Authentication Scheme\n   Copyright (c) 2012-2013, Eran Hammer <eran@hueniverse.com>\n   MIT Licensed\n   */\n\n\n  // Declare namespace\n\n  var hawk = {};\n\n  hawk.client = {\n\n    // Generate an Authorization header for a given request\n\n    /*\n     uri: 'http://example.com/resource?a=b'\n     method: HTTP verb (e.g. 'GET', 'POST')\n     options: {\n\n     // Required\n\n     credentials: {\n     id: 'dh37fgj492je',\n     key: 'aoijedoaijsdlaksjdl',\n     algorithm: 'sha256'                                 // 'sha1', 'sha256'\n     },\n\n     // Optional\n\n     ext: 'application-specific',                        // Application specific data sent via the ext attribute\n     timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds\n     nonce: '2334f34f',                                  // A pre-generated nonce\n     localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)\n     payload: '{\"some\":\"payload\"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)\n     contentType: 'application/json',                    // Payload content-type (ignored if hash provided)\n     hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash\n     app: '24s23423f34dx',                               // Oz application id\n     dlg: '234sz34tww3sd'                                // Oz delegated-by application id\n     }\n     */\n\n    header: function (uri, method, options) {\n      /*eslint complexity: [2, 21] */\n      var result = {\n        field: '',\n        artifacts: {}\n      };\n\n      // Validate inputs\n\n      if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||\n        !method || typeof method !== 'string' ||\n        !options || typeof options !== 'object') {\n\n        result.err = 'Invalid argument type';\n        return result;\n      }\n\n      // Application time\n\n      var timestamp = options.timestamp || Math.floor((hawk.utils.now() + (options.localtimeOffsetMsec || 0)) / 1000);\n\n      // Validate credentials\n\n      var credentials = options.credentials;\n      if (!credentials ||\n        !credentials.id ||\n        !credentials.key ||\n        !credentials.algorithm) {\n\n        result.err = 'Invalid credential object';\n        return result;\n      }\n\n      if (hawk.utils.baseIndexOf(hawk.crypto.algorithms, credentials.algorithm) === -1) {\n        result.err = 'Unknown algorithm';\n        return result;\n      }\n\n      // Parse URI\n\n      if (typeof uri === 'string') {\n        uri = hawk.utils.parseUri(uri);\n      }\n\n      // Calculate signature\n\n      var artifacts = {\n        ts: timestamp,\n        nonce: options.nonce || hawk.utils.randomString(6),\n        method: method,\n        resource: uri.relative,\n        host: uri.hostname,\n        port: uri.port,\n        hash: options.hash,\n        ext: options.ext,\n        app: options.app,\n        dlg: options.dlg\n      };\n\n      result.artifacts = artifacts;\n\n      // Calculate payload hash\n\n      if (!artifacts.hash &&\n        options.hasOwnProperty('payload')) {\n\n        artifacts.hash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);\n      }\n\n      var mac = hawk.crypto.calculateMac('header', credentials, artifacts);\n\n      // Construct header\n\n      var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed\n      var header = 'Hawk id=\"' + credentials.id +\n        '\", ts=\"' + artifacts.ts +\n        '\", nonce=\"' + artifacts.nonce +\n        (artifacts.hash ? '\", hash=\"' + artifacts.hash : '') +\n        (hasExt ? '\", ext=\"' + hawk.utils.escapeHeaderAttribute(artifacts.ext) : '') +\n        '\", mac=\"' + mac + '\"';\n\n      if (artifacts.app) {\n        header += ', app=\"' + artifacts.app +\n          (artifacts.dlg ? '\", dlg=\"' + artifacts.dlg : '') + '\"';\n      }\n\n      result.field = header;\n\n      return result;\n    },\n\n\n    // Validate server response\n\n    /*\n     request:    object created via 'new XMLHttpRequest()' after response received\n     artifacts:  object recieved from header().artifacts\n     options: {\n     payload:    optional payload received\n     required:   specifies if a Server-Authorization header is required. Defaults to 'false'\n     }\n     */\n\n    authenticate: function (request, credentials, artifacts, options) {\n\n      options = options || {};\n\n      if (request.getResponseHeader('www-authenticate')) {\n\n        // Parse HTTP WWW-Authenticate header\n\n        var attrsAuth = hawk.utils.parseAuthorizationHeader(request.getResponseHeader('www-authenticate'), ['ts', 'tsm', 'error']);\n        if (!attrsAuth) {\n          return false;\n        }\n\n        if (attrsAuth.ts) {\n          var tsm = hawk.crypto.calculateTsMac(attrsAuth.ts, credentials);\n          if (tsm !== attrsAuth.tsm) {\n            return false;\n          }\n\n          hawk.utils.setNtpOffset(attrsAuth.ts - Math.floor((new Date()).getTime() / 1000));     // Keep offset at 1 second precision\n        }\n      }\n\n      // Parse HTTP Server-Authorization header\n\n      if (!request.getResponseHeader('server-authorization') &&\n        !options.required) {\n\n        return true;\n      }\n\n      var attributes = hawk.utils.parseAuthorizationHeader(request.getResponseHeader('server-authorization'), ['mac', 'ext', 'hash']);\n      if (!attributes) {\n        return false;\n      }\n\n      var modArtifacts = {\n        ts: artifacts.ts,\n        nonce: artifacts.nonce,\n        method: artifacts.method,\n        resource: artifacts.resource,\n        host: artifacts.host,\n        port: artifacts.port,\n        hash: attributes.hash,\n        ext: attributes.ext,\n        app: artifacts.app,\n        dlg: artifacts.dlg\n      };\n\n      var mac = hawk.crypto.calculateMac('response', credentials, modArtifacts);\n      if (mac !== attributes.mac) {\n        return false;\n      }\n\n      if (!options.hasOwnProperty('payload')) {\n        return true;\n      }\n\n      if (!attributes.hash) {\n        return false;\n      }\n\n      var calculatedHash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.getResponseHeader('content-type'));\n      return (calculatedHash === attributes.hash);\n    },\n\n    message: function (host, port, message, options) {\n\n      // Validate inputs\n\n      if (!host || typeof host !== 'string' ||\n        !port || typeof port !== 'number' ||\n        message === null || message === undefined || typeof message !== 'string' ||\n        !options || typeof options !== 'object') {\n\n        return null;\n      }\n\n      // Application time\n\n      var timestamp = options.timestamp || Math.floor((hawk.utils.now() + (options.localtimeOffsetMsec || 0)) / 1000);\n\n      // Validate credentials\n\n      var credentials = options.credentials;\n      if (!credentials ||\n        !credentials.id ||\n        !credentials.key ||\n        !credentials.algorithm) {\n\n        // Invalid credential object\n        return null;\n      }\n\n      if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {\n        return null;\n      }\n\n      // Calculate signature\n\n      var artifacts = {\n        ts: timestamp,\n        nonce: options.nonce || hawk.utils.randomString(6),\n        host: host,\n        port: port,\n        hash: hawk.crypto.calculatePayloadHash(message, credentials.algorithm)\n      };\n\n      // Construct authorization\n\n      var result = {\n        id: credentials.id,\n        ts: artifacts.ts,\n        nonce: artifacts.nonce,\n        hash: artifacts.hash,\n        mac: hawk.crypto.calculateMac('message', credentials, artifacts)\n      };\n\n      return result;\n    },\n\n    authenticateTimestamp: function (message, credentials, updateClock) {           // updateClock defaults to true\n\n      var tsm = hawk.crypto.calculateTsMac(message.ts, credentials);\n      if (tsm !== message.tsm) {\n        return false;\n      }\n\n      if (updateClock !== false) {\n        hawk.utils.setNtpOffset(message.ts - Math.floor((new Date()).getTime() / 1000));    // Keep offset at 1 second precision\n      }\n\n      return true;\n    }\n  };\n\n\n  hawk.crypto = {\n\n    headerVersion: '1',\n\n    algorithms: ['sha1', 'sha256'],\n\n    calculateMac: function (type, credentials, options) {\n      var normalized = hawk.crypto.generateNormalizedString(type, options);\n      var hmac = new sjcl.misc.hmac(credentials.key, sjcl.hash.sha256);\n      hmac.update(normalized);\n\n      return sjcl.codec.base64.fromBits(hmac.digest());\n    },\n\n    generateNormalizedString: function (type, options) {\n\n      var normalized = 'hawk.' + hawk.crypto.headerVersion + '.' + type + '\\n' +\n        options.ts + '\\n' +\n        options.nonce + '\\n' +\n        (options.method || '').toUpperCase() + '\\n' +\n        (options.resource || '') + '\\n' +\n        options.host.toLowerCase() + '\\n' +\n        options.port + '\\n' +\n        (options.hash || '') + '\\n';\n\n      if (options.ext) {\n        normalized += options.ext.replace('\\\\', '\\\\\\\\').replace('\\n', '\\\\n');\n      }\n\n      normalized += '\\n';\n\n      if (options.app) {\n        normalized += options.app + '\\n' +\n          (options.dlg || '') + '\\n';\n      }\n\n      return normalized;\n    },\n\n    calculatePayloadHash: function (payload, algorithm, contentType) {\n      var hash = new sjcl.hash.sha256();\n      hash.update('hawk.' + hawk.crypto.headerVersion + '.payload\\n')\n        .update(hawk.utils.parseContentType(contentType) + '\\n')\n        .update(payload || '')\n        .update('\\n');\n\n      return sjcl.codec.base64.fromBits(hash.finalize());\n    },\n\n    calculateTsMac: function (ts, credentials) {\n      var hmac = new sjcl.misc.hmac(credentials.key, sjcl.hash.sha256);\n      hmac.update('hawk.' + hawk.crypto.headerVersion + '.ts\\n' + ts + '\\n');\n\n      return sjcl.codec.base64.fromBits(hmac.digest());\n    }\n  };\n\n\n  hawk.utils = {\n\n    storage: {                                      // localStorage compatible interface\n      _cache: {},\n      setItem: function (key, value) {\n\n        hawk.utils.storage._cache[key] = value;\n      },\n      getItem: function (key) {\n\n        return hawk.utils.storage._cache[key];\n      }\n    },\n\n    setStorage: function (storage) {\n\n      var ntpOffset = hawk.utils.getNtpOffset() || 0;\n      hawk.utils.storage = storage;\n      hawk.utils.setNtpOffset(ntpOffset);\n    },\n\n    setNtpOffset: function (offset) {\n\n      try {\n        hawk.utils.storage.setItem('hawk_ntp_offset', offset);\n      }\n      catch (err) {\n        console.error('[hawk] could not write to storage.');\n        console.error(err);\n      }\n    },\n\n    getNtpOffset: function () {\n\n      return parseInt(hawk.utils.storage.getItem('hawk_ntp_offset') || '0', 10);\n    },\n\n    now: function () {\n\n      return (new Date()).getTime() + hawk.utils.getNtpOffset();\n    },\n\n    escapeHeaderAttribute: function (attribute) {\n\n      return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');\n    },\n\n    parseContentType: function (header) {\n\n      if (!header) {\n        return '';\n      }\n\n      return header.split(';')[0].replace(/^\\s+|\\s+$/g, '').toLowerCase();\n    },\n\n    parseAuthorizationHeader: function (header, keys) {\n\n      if (!header) {\n        return null;\n      }\n\n      var headerParts = header.match(/^(\\w+)(?:\\s+(.*))?$/);       // Header: scheme[ something]\n      if (!headerParts) {\n        return null;\n      }\n\n      var scheme = headerParts[1];\n      if (scheme.toLowerCase() !== 'hawk') {\n        return null;\n      }\n\n      var attributesString = headerParts[2];\n      if (!attributesString) {\n        return null;\n      }\n\n      var attributes = {};\n      var verify = attributesString.replace(/(\\w+)=\"([^\"\\\\]*)\"\\s*(?:,\\s*|$)/g, function ($0, $1, $2) {\n\n        // Check valid attribute names\n\n        if (keys.indexOf($1) === -1) {\n          return;\n        }\n\n        // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9\n\n        if ($2.match(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~]+$/) === null) {\n          return;\n        }\n\n        // Check for duplicates\n\n        if (attributes.hasOwnProperty($1)) {\n          return;\n        }\n\n        attributes[$1] = $2;\n        return '';\n      });\n\n      if (verify !== '') {\n        return null;\n      }\n\n      return attributes;\n    },\n\n    randomString: function (size) {\n\n      var randomSource = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n      var len = randomSource.length;\n\n      var result = [];\n      for (var i = 0; i < size; ++i) {\n        result[i] = randomSource[Math.floor(Math.random() * len)];\n      }\n\n      return result.join('');\n    },\n\n    baseIndexOf: function(array, value, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n      while (++index < length) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    },\n\n    parseUri: function (input) {\n\n      // Based on: parseURI 1.2.2\n      // http://blog.stevenlevithan.com/archives/parseuri\n      // (c) Steven Levithan <stevenlevithan.com>\n      // MIT License\n\n      var keys = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'hostname', 'port', 'resource', 'relative', 'pathname', 'directory', 'file', 'query', 'fragment'];\n\n      var uriRegex = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?(((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?)(?:#(.*))?)/;\n      var uriByNumber = uriRegex.exec(input);\n      var uri = {};\n\n      var i = 15;\n      while (i--) {\n        uri[keys[i]] = uriByNumber[i] || '';\n      }\n\n      if (uri.port === null ||\n        uri.port === '') {\n\n        uri.port = (uri.protocol.toLowerCase() === 'http' ? '80' : (uri.protocol.toLowerCase() === 'https' ? '443' : ''));\n      }\n\n      return uri;\n    }\n  };\n\n\n  return hawk;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/lib/hawk.js\n// module id = 9\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\ndefine(['sjcl'], function (sjcl, P) {\n  'use strict';\n\n  /**\n   * @class pbkdf2\n   * @constructor\n   */\n  var pbkdf2 = {\n    /**\n     * @method derive\n     * @param  {bitArray} input The password hex buffer.\n     * @param  {bitArray} salt The salt string buffer.\n     * @return {int} iterations the derived key bit array.\n     */\n    derive: function(input, salt, iterations, len) {\n      var result = sjcl.misc.pbkdf2(input, salt, iterations, len, sjcl.misc.hmac);\n      return Promise.resolve(result);\n    }\n  };\n\n  return pbkdf2;\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/lib/pbkdf2.js\n// module id = 10\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\ndefine(['sjcl', './hkdf'], function (sjcl, hkdf) {\n  'use strict';\n\n  var PREFIX_NAME = 'identity.mozilla.com/picl/v1/';\n  var bitSlice = sjcl.bitArray.bitSlice;\n  var salt = sjcl.codec.hex.toBits('');\n\n  /**\n   * @class hawkCredentials\n   * @method deriveHawkCredentials\n   * @param {String} tokenHex\n   * @param {String} context\n   * @param {int} size\n   * @returns {Promise}\n   */\n  function deriveHawkCredentials(tokenHex, context, size) {\n    var token = sjcl.codec.hex.toBits(tokenHex);\n    var info = sjcl.codec.utf8String.toBits(PREFIX_NAME + context);\n\n    return hkdf(token, info, salt, size || 3 * 32)\n      .then(function(out) {\n        var authKey = bitSlice(out, 8 * 32, 8 * 64);\n        var bundleKey = bitSlice(out, 8 * 64);\n\n        return {\n          algorithm: 'sha256',\n          id: sjcl.codec.hex.fromBits(bitSlice(out, 0, 8 * 32)),\n          key: authKey,\n          bundleKey: bundleKey\n        };\n      });\n  }\n\n  return deriveHawkCredentials;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/lib/hawkCredentials.js\n// module id = 11\n// module chunks = 0 1","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// This module does the handling for the metrics context\n// activity event metadata.\n\ndefine([], function () {\n  'use strict';\n\n  return {\n    marshall: function (data) {\n      return {\n        deviceId: data.deviceId,\n        flowId: data.flowId,\n        flowBeginTime: data.flowBeginTime,\n        utmCampaign: data.utmCampaign,\n        utmContent: data.utmContent,\n        utmMedium: data.utmMedium,\n        utmSource: data.utmSource,\n        utmTerm: data.utmTerm\n      };\n    }\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/lib/metricsContext.js\n// module id = 12\n// module chunks = 0 1"],"sourceRoot":""}